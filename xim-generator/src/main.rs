// MIT/Apache2 License

use anyhow::{anyhow, Result};
use heck::{ToSnakeCase, ToUpperCamelCase};
use regex::Regex;
use std::{
    collections::{BTreeMap, HashMap, HashSet},
    env, fs,
    io::{prelude::*, BufReader, BufWriter},
};

fn main() -> Result<()> {
    let mut args = env::args_os();

    // open the C file we have to parse
    let proto_file = args
        .nth(1)
        .ok_or_else(|| anyhow!("protocol file name expected"))?;
    let proto_file = BufReader::new(fs::File::open(proto_file)?);

    // also open the output file
    let out_file = args
        .next()
        .ok_or_else(|| anyhow!("output file name expected"))?;
    let mut out_file = BufWriter::new(fs::File::create(out_file)?);

    let items = parse_c_file(proto_file)?;

    writeln!(
        out_file,
        "
// This file is generated by xim-generator.

use alloc::{{borrow::Cow, vec::Vec}};
use crate::{{frame::{{Frame, ParseError, WithRemainder}}, roundup}};
#[cfg(test)]
use crate::frame::GenRandom;
    "
    )?;

    // load from the data file
    let data_file = args
        .next()
        .ok_or_else(|| anyhow!("data file name expected"))?;
    let mut data_file = fs::File::open(data_file)?;
    let mut data = vec![];
    data_file.read_to_end(&mut data)?;
    let data_file: DataFile = toml::de::from_slice(&data)?;

    let mut state = Default::default();
    for item in items {
        let ty = XimType::new(item, &mut state)?;
        ty.generate(&mut out_file, &state, &data_file)?;
    }

    generate_common(&mut out_file, &state, &data_file)?;

    Ok(())
}

/// Parse the C file into the functions required.
fn parse_c_file(file: impl BufRead) -> Result<Vec<Item>> {
    let mut items = vec![];
    let mut current_item = None;

    // regexes to use to parse the file
    let header_regex = Regex::new(r"XimFrameRec (.*)\[\] = \{")?;
    let frame_regex = Regex::new(r"([a-zA-Z0-9_\(\)]+),(\s+/\* ([\w\s\-\.]+) \*/)?")?;
    let ptr_regex = Regex::new(r"_PTR\((.*)\)")?;

    // run over the lines of the file
    for (i, line) in file.lines().enumerate() {
        let line = line?;

        if let Some(capture) = header_regex.captures(&line) {
            // if we have a match, we have a new item
            if let Some(last_item) = current_item.take() {
                items.push(last_item);
            }

            let item = Item {
                name: capture[1].to_string(),
                frames: vec![],
            };

            current_item = Some(item);
            continue;
        }

        // if the line is the definition, make the new item
        if let Some(ref mut item) = current_item {
            // split the type and the comment that may defined the name
            if let Some(capture) = frame_regex.captures(&line) {
                let name = capture.get(3).map(|s| s.as_str().to_string());
                let attr = match &capture[1] {
                    a if a.contains("BIT8") => RType::U8,
                    a if a.contains("BIT16") => RType::U16,
                    a if a.contains("BIT32") => RType::U32,
                    "_FRAME(EOL)" => RType::Eol,
                    a if a.starts_with("_PAD4") => RType::Pad4,
                    a if a.starts_with("_PAD2") => RType::Pad2,
                    "_FRAME(BARRAY)" => RType::Barray,
                    "_FRAME(ITER)" => RType::Iter,
                    "_FRAME(POINTER)" => RType::Pointer,
                    a if a.starts_with("_PTR") => {
                        if let Some(captures) = ptr_regex.captures(a) {
                            RType::PointerTo(captures[1].to_string())
                        } else {
                            return Err(anyhow!("failed to parse pointer"));
                        }
                    }
                    a => {
                        return Err(anyhow!(
                            "unknown type for {:?} in {} ({}): {}",
                            &name,
                            &item.name,
                            i,
                            a
                        ))
                    }
                };
                let is_byte_counter = capture[1].contains("_BYTE_COUNTER");

                let frame = Frame {
                    attr,
                    name,
                    is_byte_counter,
                };

                item.frames.push(frame);
            }
        }
    }

    items.extend(current_item);
    Ok(items)
}

fn generate_common(mut out: impl Write, state: &GeneratorState, data: &DataFile) -> Result<()> {
    // opcode enum
    writeln!(out, "#[repr(u8)]")?;
    writeln!(out, "enum Opcode {{")?;

    for (name, opcode) in &data.opcodes {
        writeln!(out, "    {} = {},", name, opcode)?;
    }

    writeln!(out, "}}")?;
    writeln!(out, "impl TryFrom<u8> for Opcode {{")?;
    writeln!(out, "    type Error = OutOfRange;")?;
    writeln!(
        out,
        "    fn try_from(val: u8) -> Result<Self, OutOfRange> {{"
    )?;
    writeln!(out, "        match val {{")?;

    for (name, opcode) in &data.opcodes {
        writeln!(out, "            {} => Ok(Opcode::{}),", opcode, name)?;
    }

    writeln!(out, "            _ => Err(OutOfRange),")?;
    writeln!(out, "        }}")?;
    writeln!(out, "    }}")?;
    writeln!(out, "}}")?;

    // ximframe enum
    writeln!(
        out,
        "#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]",
    )?;
    writeln!(
        out,
        r#"#[cfg_attr(feature = "serde", derive(serde::Deserialize, serde::Serialize))]"#,
    )?;
    writeln!(out, "pub enum XimFrame<'a> {{")?;

    for (name, _) in &data.opcodes {
        if name != "Extension" {
            write!(out, "    {0}({0}Fr", name)?;

            let silly_name = format!("{}_fr", heck::AsSnakeCase(&name));

            if state.lifetime_types.contains(&silly_name) {
                write!(out, "<'a>")?;
            }

            writeln!(out, "),")?;
        }
    }

    writeln!(out, "    Extension {{")?;
    writeln!(out, "        minor_opcode: u8,")?;
    writeln!(out, "        data: Vec<u8>,")?;
    writeln!(out, "    }},")?;
    writeln!(out, "    Unknown {{")?;
    writeln!(out, "        major_opcode: u8,")?;
    writeln!(out, "        minor_opcode: u8,")?;
    writeln!(out, "        data: Vec<u8>,")?;
    writeln!(out, "    }},")?;
    writeln!(out, "}}")?;

    // frame implementation
    writeln!(out, "impl<'a> Frame for XimFrame<'a> {{")?;
    writeln!(
        out,
        "    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {{"
    )?;

    // fetch the header
    writeln!(
        out,
        "        let header = bytes.get(..4).ok_or(ParseError {{"
    )?;
    writeln!(out, "            expected: 4,")?;
    writeln!(out, "            got: bytes.len(),")?;
    writeln!(out, "        }})?;")?;

    // match on the header major opcode byte
    writeln!(out, "        match Opcode::try_from(header[0]) {{")?;

    for name in data.opcodes.keys() {
        if name != "Extension" {
            writeln!(out, "            Ok(Opcode::{0}) => {{", name)?;
            writeln!(
                out,
                "                let (frame, rest) = {0}Fr::parse(&bytes[4..])?;",
                name
            )?;
            writeln!(
                out,
                "                Ok((XimFrame::{0}(frame), rest))",
                name
            )?;
            writeln!(out, "            }},")?;
        }
    }

    // write for special cases
    writeln!(out, "            Ok(Opcode::Extension) => {{")?;
    writeln!(out, "                let minor_opcode = bytes[1];")?;
    writeln!(out, "                let data = bytes[4..].to_vec();")?;
    writeln!(
        out,
        "                Ok((XimFrame::Extension {{ minor_opcode, data }}, &[]))"
    )?;
    writeln!(out, "            }},")?;
    writeln!(out, "            Err(OutOfRange) => {{")?;
    writeln!(out, "                let major_opcode = bytes[0];")?;
    writeln!(out, "                let minor_opcode = bytes[1];")?;
    writeln!(out, "                let data = bytes[4..].to_vec();")?;
    writeln!(
        out,
        "                Ok((XimFrame::Unknown {{ major_opcode, minor_opcode, data }},"
    )?;
    writeln!(out, "                   &[]))")?;
    writeln!(out, "            }},")?;

    writeln!(out, "        }}")?;

    writeln!(out, "    }}")?;
    writeln!(out, "    fn size(&self) -> usize {{")?;
    writeln!(out, "        let base_size = match self {{")?;

    for name in data.opcodes.keys() {
        if name != "Extension" {
            writeln!(
                out,
                "            XimFrame::{0}(frame) => frame.size(),",
                name
            )?;
        }
    }

    writeln!(
        out,
        "            XimFrame::Extension {{ data, .. }} => data.len(),"
    )?;
    writeln!(
        out,
        "            XimFrame::Unknown {{ data, .. }} => data.len(),"
    )?;
    writeln!(out, "        }};")?;
    writeln!(out, "        base_size + HEADER_SIZE")?;
    writeln!(out, "    }}")?;
    writeln!(
        out,
        "    fn serialize(&self, target: &mut [u8]) -> usize {{"
    )?;

    // do a hybrid of serializing and fetching into
    writeln!(out, "        let (major, minor, len) = match self {{")?;

    for name in data.opcodes.keys() {
        if name != "Extension" {
            writeln!(out, "            XimFrame::{0}(frame) => {{", name)?;
            writeln!(out, "                let major = Opcode::{0} as u8;", name)?;
            writeln!(
                out,
                "                let len = frame.serialize(&mut target[HEADER_SIZE..]);"
            )?;
            writeln!(out, "                (major, 0, len)")?;
            writeln!(out, "            }},")?;
        }
    }

    // special cases
    writeln!(
        out,
        "            XimFrame::Extension {{ minor_opcode, data, .. }} => {{"
    )?;
    writeln!(out, "                let major = Opcode::Extension as u8;")?;
    writeln!(out, "                let len = data.len();")?;
    writeln!(
        out,
        "                target[HEADER_SIZE..HEADER_SIZE + len].copy_from_slice(data);"
    )?;
    writeln!(out, "                (major, *minor_opcode, len)")?;
    writeln!(out, "            }},")?;
    writeln!(
        out,
        "            XimFrame::Unknown {{ major_opcode, minor_opcode, data, .. }} => {{"
    )?;
    writeln!(out, "                let len = data.len();")?;
    writeln!(
        out,
        "                target[HEADER_SIZE..HEADER_SIZE + len].copy_from_slice(data);"
    )?;
    writeln!(out, "                (*major_opcode, *minor_opcode, len)")?;
    writeln!(out, "            }},")?;
    writeln!(out, "        }};")?;

    // write what's left
    writeln!(out, "        let xlen = (roundup(len, 4) / 4) as u16;")?;
    writeln!(out, "        target[0] = major;")?;
    writeln!(out, "        target[1] = minor;")?;
    writeln!(out, "        xlen.serialize(&mut target[2..]);")?;
    writeln!(out, "        len + HEADER_SIZE")?;
    writeln!(out, "    }}")?;
    writeln!(out, "}}")?;

    writeln!(out, "struct OutOfRange;")?;
    writeln!(out, "const HEADER_SIZE: usize = 4;")?;

    // write a sanity test for each instance
    writeln!(out, "#[cfg(test)]")?;
    writeln!(out, "#[test]")?;
    writeln!(out, "fn ximframe_sanity() {{")?;
    writeln!(out, "    fn test_frame(test_case: XimFrame) {{")?;
    // this is the same test from before
    writeln!(
        out,
        "
        let mut target = alloc::vec![0u8; test_case.size()];
        assert_eq!(test_case.serialize(&mut target), test_case.size());
        let (deser, rem) = XimFrame::parse(&target).unwrap();
        assert_eq!(rem.len(), 0);
        assert_eq!(test_case, deser);
        ",
    )?;
    writeln!(out, "    }}")?;

    // call it once for each variant
    for name in data.opcodes.keys() {
        if name != "Extension" {
            writeln!(out, "    test_frame({0}Fr::generate().into());", name)?;
        }
    }

    writeln!(
        out,
        "
    test_frame(XimFrame::Extension {{ 
        minor_opcode: fastrand::u8(..),
        data: core::iter::repeat_with(|| fastrand::u8(..))
            .take(fastrand::usize(..255))
            .collect() 
    }});
        "
    )?;
    writeln!(
        out,
        "
    test_frame(XimFrame::Unknown {{ 
        major_opcode: fastrand::u8(129..),
        minor_opcode: fastrand::u8(..), 
        data: core::iter::repeat_with(|| fastrand::u8(..))
            .take(fastrand::usize(..255))
            .collect() 
    }});
        "
    )?;

    writeln!(out, "}}")?;

    Ok(())
}

#[derive(Debug)]
struct Item {
    name: String,
    frames: Vec<Frame>,
}

struct XimType {
    name: String,
    fields: Vec<Field>,
    copyable: bool,
    #[allow(dead_code)]
    byte_equivalent: bool,
    needs_lifetime: bool,
}

#[derive(Default)]
struct GeneratorState {
    copyable_types: HashSet<String>,
    byte_equivalent_types: HashSet<String>,
    lifetime_types: HashSet<String>,
}

impl XimType {
    fn new(value: Item, state: &mut GeneratorState) -> Result<Self> {
        let Item { name, frames } = value;

        let mut fields = vec![];
        let mut expecting_iter_item = None;
        let mut expecting_ptr_item = false;

        let mut copyable = true;
        let mut byte_equivalent = true;
        let mut needs_lifetime = false;

        // begin converting struct fields
        for (
            i,
            Frame {
                attr,
                name,
                is_byte_counter: byte_counter,
            },
        ) in frames.into_iter().enumerate()
        {
            let name = name.unwrap_or_else(|| format!("field{}", i));
            let field = match attr {
                RType::U8 => Field::True {
                    name: name.clone(),
                    ty: FieldTy::U8,
                    byte_counter,
                },
                RType::U16 => Field::True {
                    name: name.clone(),
                    ty: FieldTy::U16,
                    byte_counter,
                },
                RType::U32 => Field::True {
                    name: name.clone(),
                    ty: FieldTy::U32,
                    byte_counter,
                },
                RType::Eol => break,
                RType::Pad4 => {
                    byte_equivalent = false;
                    Field::Padding(4)
                }
                RType::Pad2 => {
                    byte_equivalent = false;
                    Field::Padding(2)
                }
                RType::Barray => {
                    byte_equivalent = false;
                    copyable = false;
                    needs_lifetime = true;

                    // pop off latest length field
                    let posn = fields
                        .iter()
                        .rposition(|f| match f {
                            Field::True { name, .. } => name.contains("length"),
                            _ => false,
                        })
                        .unwrap_or(fields.len() - 1);

                    Field::ByteList {
                        name: name.clone(),
                        length_posn: posn,
                    }
                }
                RType::Pointer => {
                    expecting_ptr_item = true;
                    continue;
                }
                RType::PointerTo(pointee) => {
                    if !expecting_ptr_item {
                        return Err(anyhow!("wasn't expecting a ptr"));
                    }

                    if !state.copyable_types.contains(&pointee) {
                        copyable = false;
                    }
                    if !state.byte_equivalent_types.contains(&pointee) {
                        byte_equivalent = false;
                    }
                    if state.lifetime_types.contains(&pointee) {
                        needs_lifetime = true;
                    }

                    expecting_ptr_item = false;
                    Field::Pointer {
                        other_ty_name: pointee,
                        name: name.clone(),
                    }
                }
                RType::Iter => {
                    expecting_iter_item = Some(name);
                    byte_equivalent = false;
                    copyable = false;
                    continue;
                }
            };

            // if we were expecting an iterator item, this is it
            let field = if let Some(name) = expecting_iter_item.take() {
                // get the byte counter from earlier
                let bc_index = fields
                    .iter()
                    .rposition(|f| match f {
                        Field::True { byte_counter, .. } => *byte_counter,
                        _ => false,
                    })
                    .ok_or_else(|| anyhow!("no byte counter"))?;

                // create a list of the field
                Field::ListOf {
                    other_ty: Box::new(field),
                    counter_index: bc_index,
                    name,
                }
            } else {
                field
            };

            fields.push(field);
        }

        if copyable {
            state.copyable_types.insert(name.clone());
        }
        if byte_equivalent {
            state.byte_equivalent_types.insert(name.clone());
        }
        if needs_lifetime {
            state.lifetime_types.insert(name.clone());
        }

        Ok(Self {
            name,
            fields,
            copyable,
            byte_equivalent,
            needs_lifetime,
        })
    }

    /// Generate the Rust code for this type
    fn generate(&self, mut out: impl Write, state: &GeneratorState, df: &DataFile) -> Result<()> {
        // what traits do we derive?
        let mut traits = vec![
            "Debug",
            "Clone",
            "PartialEq",
            "Eq",
            "PartialOrd",
            "Ord",
            "Hash",
            "Default",
        ];
        if self.copyable {
            traits.push("Copy");
        }

        write!(out, "#[derive(")?;
        for tr in traits {
            write!(out, "{},", tr)?;
        }
        writeln!(out, ")]")?;

        writeln!(
            out,
            r#"#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]"#
        )?;

        // write the struct definition
        writeln!(out, "pub struct {} {{", self.sname())?;

        for (i, field) in self.fields.iter().enumerate() {
            if self.is_implied(i) {
                continue;
            }

            if let Some(emitted) = field.emit(state) {
                writeln!(out, "    {},", emitted)?;
            }
        }

        writeln!(out, "}}")?;

        // write the impl for the Frame trait
        self.impl_keyword(&mut out)?;
        writeln!(out, "Frame for {} {{", self.sname())?;
        writeln!(
            out,
            "    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {{"
        )?;
        writeln!(out, "        let _start = bytes;")?;

        for i in 0..self.fields.len() {
            let expr = self.parse_expr(i, state);
            writeln!(out, "        {}", expr)?;
        }

        // write in each field
        writeln!(out, "        Ok((Self {{")?;
        for (i, field) in self.fields.iter().enumerate() {
            if self.is_implied(i) {
                continue;
            }

            let name = field.name();
            writeln!(out, "            {},", name)?;
        }
        writeln!(out, "        }}, bytes))")?;

        writeln!(out, "    }}")?;
        writeln!(out, "    fn size(&self) -> usize {{")?;

        // calculate the size of the struct
        if self.fields.is_empty() {
            writeln!(out, "        0")?;
        } else {
            writeln!(out, "        let mut size = 0usize;")?;
            for i in 0..self.fields.len() {
                writeln!(out, "        {};", self.size_expr(i))?;
            }
            writeln!(out, "        size")?;
        }

        writeln!(out, "    }}")?;
        writeln!(
            out,
            "    fn serialize(&self, target: &mut [u8]) -> usize {{"
        )?;

        if self.fields.is_empty() {
            writeln!(out, "        let _ = target;")?;
            writeln!(out, "        0")?;
        } else {
            writeln!(out, "        let mut posn = 0usize;")?;

            for i in 0..self.fields.len() {
                writeln!(out, "        {}", self.serialize_expr(i))?;
            }

            writeln!(out, "        posn")?;
        }
        writeln!(out, "    }}")?;
        writeln!(out, "}}")?;

        // add a GenRandom impl for testing
        writeln!(out, "#[cfg(test)]")?;
        self.impl_keyword(&mut out)?;
        writeln!(out, "GenRandom for {} {{", self.sname())?;
        writeln!(out, "    fn generate() -> Self {{")?;
        writeln!(out, "        Self {{")?;

        for (i, field) in self.fields.iter().enumerate() {
            if self.is_implied(i) {
                continue;
            }

            let name = field.name();
            match field {
                Field::True { .. } | Field::Pointer { .. } => {
                    writeln!(out, "            {}: GenRandom::generate(),", name)?;
                }
                Field::ByteList { .. } => {
                    writeln!(
                        out,
"            {}: core::iter::repeat_with(|| fastrand::u8(..)).take(fastrand::usize(..255)).collect(),",
                        name
                    )?;
                }
                Field::ListOf { .. } => {
                    writeln!(
                        out,
"            {}: core::iter::repeat_with(GenRandom::generate).take(fastrand::usize(..255)).collect(),",
                        name,
                    )?;
                }
                _ => {}
            }
        }

        writeln!(out, "        }}")?;
        writeln!(out, "    }}")?;
        writeln!(out, "}}")?;

        // add a sanity test to ensure that the serialization goes smoothly
        writeln!(out, "#[cfg(test)]")?;
        writeln!(out, "#[test]")?;
        writeln!(
            out,
            "fn {}_sanity() {{",
            heck::AsSnakeCase(self.name.as_str())
        )?;
        writeln!(
            out,
            "
    // serialize a randomly generated test case to a buffer
    let test_case = {0}::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = {0}::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            ",
            heck::AsUpperCamelCase(&self.name),
        )?;
        writeln!(out, "}}")?;

        // add an into impl for XimFrame if applicable
        let shorter_name = self.name.split("_fr").next().unwrap().to_upper_camel_case();
        if df.opcodes.contains_key(&shorter_name) {
            writeln!(out, "impl<'a> From<{}> for XimFrame<'a> {{", self.sname())?;
            writeln!(out, "    fn from(val: {}) -> XimFrame<'a> {{", self.sname())?;
            writeln!(out, "        XimFrame::{}(val)", shorter_name)?;
            writeln!(out, "    }}")?;
            writeln!(out, "}}")?;
        }

        Ok(())
    }

    fn sname(&self) -> String {
        let mut name = self.name.to_upper_camel_case();
        if self.needs_lifetime {
            name.push_str("<'a>");
        }
        name
    }

    fn impl_keyword(&self, mut wr: impl Write) -> Result<()> {
        write!(wr, "impl")?;
        if self.needs_lifetime {
            write!(wr, "<'a>")?;
        }
        write!(wr, " ")?;
        Ok(())
    }

    fn is_implied(&self, index: usize) -> bool {
        for (i, field) in self.fields.iter().enumerate() {
            match field {
                Field::True {
                    byte_counter: true, ..
                }
                | Field::Padding(_) => {
                    if index == i {
                        return true;
                    }
                }
                Field::ByteList { length_posn, .. }
                | Field::ListOf {
                    counter_index: length_posn,
                    ..
                } => {
                    if *length_posn == index {
                        return true;
                    }
                }
                _ => {}
            }
        }

        false
    }

    fn parse_expr(&self, index: usize, state: &GeneratorState) -> String {
        let name = self.fields[index].name();

        match &self.fields[index] {
            Field::True { ty, .. } => {
                format!("let ({}, bytes) = {}::parse(bytes)?;", name, ty.as_str())
            }
            Field::Padding(n) => {
                format!(
                    "
        let bytes_so_far = (bytes.as_ptr() as usize) - (_start.as_ptr() as usize);
        let padding_len = match bytes_so_far % {0} {{
            0 => 0,
            rem => {0} - rem,
        }};
        let bytes = bytes.get(padding_len..).ok_or(
            ParseError {{
                expected: padding_len,
                got: bytes.len(),
            }}
        )?;
                ",
                    n
                )
            }
            Field::Pointer { other_ty_name, .. } => {
                format!(
                    "let ({}, bytes) = {}::parse(bytes)?;",
                    name,
                    heck::AsUpperCamelCase(other_ty_name)
                )
            }
            Field::ByteList { length_posn, .. } => {
                let lp_name = self.fields[*length_posn].name();
                format!(
                    "
        if {1} as usize > bytes.len() {{
            return Err(ParseError {{
                expected: {1} as usize,
                got: bytes.len(),
            }});
        }}
        let ({0}, bytes) = bytes.split_at({1} as usize);
        let {0} = Cow::Owned({0}.to_vec());
                    ",
                    name, lp_name
                )
            }
            Field::ListOf {
                other_ty,
                counter_index,
                ..
            } => {
                let counter_name = self.fields[*counter_index].name();
                let other_ty_name = other_ty
                    .rust_type(false, state)
                    .expect("no rust type for iter");
                format!(
                    "
        let mut {0} = Vec::with_capacity({1} as usize);
        let mut bytes = bytes;

        for _ in 0..{1} {{
            let (val, rem) = {2}::parse(bytes)?;
            {0}.push(val);
            bytes = rem;
        }}
                ",
                    name, counter_name, other_ty_name,
                )
            }
        }
    }

    fn size_expr(&self, index: usize) -> String {
        let name = self.fields[index].name();

        match &self.fields[index] {
            Field::True { ty, .. } => {
                let sz = *ty as usize / 8;
                format!("size += {}", sz)
            }
            Field::Padding(n) => {
                format!("size = roundup(size, {})", n)
            }
            Field::Pointer { .. } => format!("size += self.{}.size()", name),
            Field::ByteList { .. } => {
                format!("size += self.{}.len()", name)
            }
            Field::ListOf { .. } => {
                format!(
                    "size += self.{}.iter().fold(0, |acc, t| acc + t.size())",
                    name
                )
            }
        }
    }

    fn serialize_expr(&self, index: usize) -> String {
        let name = self.fields[index].name();

        match &self.fields[index] {
            Field::True { ty, .. } => {
                // this field may be implied; if so, use the explicit
                // variable instead
                for field in &self.fields {
                    match field {
                        Field::ByteList { length_posn, .. }
                        | Field::ListOf {
                            counter_index: length_posn,
                            ..
                        } => {
                            if *length_posn == index {
                                // here we are
                                let name = field.name();
                                return format!(
                                    "posn += (self.{}.len() as {}).serialize(&mut target[posn..]);",
                                    name,
                                    ty.as_str()
                                );
                            }
                        }
                        _ => {}
                    }
                }

                format!("posn += self.{}.serialize(&mut target[posn..]);", name)
            }
            Field::Padding(n) => format!("posn = roundup(posn, {});", n),
            Field::Pointer { .. } => {
                format!("posn += self.{}.serialize(&mut target[posn..]);", name)
            }
            Field::ByteList { .. } => {
                format!(
                    "
        let blen = self.{0}.len();
        target[posn..posn + blen].copy_from_slice(&self.{0});
        posn += blen;
                ",
                    name
                )
            }
            Field::ListOf { .. } => {
                format!(
                    "
        for t in &self.{0} {{
            posn += t.serialize(&mut target[posn..]);
        }}
                ",
                    name
                )
            }
        }
    }
}

#[derive(Debug)]
struct Frame {
    attr: RType,
    name: Option<String>,
    is_byte_counter: bool,
}

#[derive(Debug)]
enum Field {
    True {
        name: String,
        ty: FieldTy,
        byte_counter: bool,
    },
    Padding(usize),
    ByteList {
        name: String,
        length_posn: usize,
    },
    Pointer {
        other_ty_name: String,
        name: String,
    },
    ListOf {
        other_ty: Box<Field>,
        counter_index: usize,
        name: String,
    },
}

impl Field {
    fn unformatted_name(&self) -> String {
        match self {
            Field::True { name, .. } => name.clone(),
            Field::Padding(_) => "padding".to_string(),
            Field::ByteList { name, .. } => name.clone(),
            Field::Pointer { name, .. } => name.clone(),
            Field::ListOf { name, .. } => name.clone(),
        }
    }

    fn name(&self) -> String {
        let mut name = self.unformatted_name().to_snake_case();
        if name == "type" {
            name = "ty".to_string();
        }
        name
    }

    fn rust_type(&self, add_lt: bool, state: &GeneratorState) -> Option<String> {
        match self {
            Self::True { ty, .. } => Some(ty.as_str().to_string()),
            Self::ByteList { .. } => Some("Cow<'a, [u8]>".into()),
            Self::Pointer { other_ty_name, .. } => {
                let tyname = other_ty_name.clone();
                if state.lifetime_types.contains(&tyname) && add_lt {
                    Some(format!("{}<'a>", heck::AsUpperCamelCase(tyname)))
                } else {
                    Some(tyname.to_upper_camel_case())
                }
            }
            Self::ListOf { other_ty, .. } => {
                let other_ty = other_ty
                    .rust_type(add_lt, state)
                    .expect("other ty needs real type");
                Some(format!("Vec<{}>", other_ty))
            }
            _ => None,
        }
    }

    fn emit(&self, state: &GeneratorState) -> Option<String> {
        self.rust_type(true, state)
            .map(|ty| format!("pub {}: {}", self.name(), &ty))
    }
}

#[derive(Debug, Copy, Clone)]
#[repr(u8)]
enum FieldTy {
    U8 = 8,
    U16 = 16,
    U32 = 32,
}

impl FieldTy {
    fn as_str(&self) -> &'static str {
        match self {
            Self::U8 => "u8",
            Self::U16 => "u16",
            Self::U32 => "u32",
        }
    }
}

#[derive(Debug)]
enum RType {
    U8,
    U16,
    U32,
    Eol,
    Pad2,
    Pad4,
    Barray,
    Iter,
    Pointer,
    PointerTo(String),
}

#[derive(serde::Deserialize)]
struct DataFile {
    opcodes: BTreeMap<String, u8>,
}
