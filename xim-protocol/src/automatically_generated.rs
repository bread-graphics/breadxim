
// This file is generated by xim-generator.

use alloc::{borrow::Cow, vec::Vec};
use crate::{frame::{Frame, ParseError, WithRemainder}, roundup};
#[cfg(test)]
use crate::frame::GenRandom;
    
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct XimattrFr<'a> {
    pub attribute_id: u16,
    pub type_of_the_value: u16,
    pub im_attribute: Cow<'a, [u8]>,
}
impl<'a> Frame for XimattrFr<'a> {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (attribute_id, bytes) = u16::parse(bytes)?;
        let (type_of_the_value, bytes) = u16::parse(bytes)?;
        let (length_of_im_attribute, bytes) = u16::parse(bytes)?;
        
        if length_of_im_attribute as usize > bytes.len() {
            return Err(ParseError {
                expected: length_of_im_attribute as usize,
                got: bytes.len(),
            });
        }
        let (im_attribute, bytes) = bytes.split_at(length_of_im_attribute as usize);
        let im_attribute = Cow::Owned(im_attribute.to_vec());
                    
        
        let bytes_so_far = (bytes.as_ptr() as usize) - (_start.as_ptr() as usize);
        let padding_len = match bytes_so_far % 4 {
            0 => 0,
            rem => 4 - rem,
        };
        let bytes = bytes.get(padding_len..).ok_or(
            ParseError {
                expected: padding_len,
                got: bytes.len(),
            }
        )?;
                
        Ok((Self {
            attribute_id,
            type_of_the_value,
            im_attribute,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size += 2;
        size += 2;
        size += self.im_attribute.len();
        size = roundup(size, 4);
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.attribute_id.serialize(&mut target[posn..]);
        posn += self.type_of_the_value.serialize(&mut target[posn..]);
        posn += (self.im_attribute.len() as u16).serialize(&mut target[posn..]);
        
        let blen = self.im_attribute.len();
        target[posn..posn + blen].copy_from_slice(&self.im_attribute);
        posn += blen;
                
        posn = roundup(posn, 4);
        posn
    }
}
#[cfg(test)]
impl<'a> GenRandom for XimattrFr<'a> {
    fn generate() -> Self {
        Self {
            attribute_id: GenRandom::generate(),
            type_of_the_value: GenRandom::generate(),
            im_attribute: core::iter::repeat_with(|| fastrand::u8(..)).take(fastrand::usize(..255)).collect(),
        }
    }
}
#[cfg(test)]
#[test]
fn ximattr_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = XimattrFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = XimattrFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct XicattrFr<'a> {
    pub attribute_id: u16,
    pub type_of_the_value: u16,
    pub ic_attribute: Cow<'a, [u8]>,
}
impl<'a> Frame for XicattrFr<'a> {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (attribute_id, bytes) = u16::parse(bytes)?;
        let (type_of_the_value, bytes) = u16::parse(bytes)?;
        let (length_of_ic_attribute, bytes) = u16::parse(bytes)?;
        
        if length_of_ic_attribute as usize > bytes.len() {
            return Err(ParseError {
                expected: length_of_ic_attribute as usize,
                got: bytes.len(),
            });
        }
        let (ic_attribute, bytes) = bytes.split_at(length_of_ic_attribute as usize);
        let ic_attribute = Cow::Owned(ic_attribute.to_vec());
                    
        
        let bytes_so_far = (bytes.as_ptr() as usize) - (_start.as_ptr() as usize);
        let padding_len = match bytes_so_far % 4 {
            0 => 0,
            rem => 4 - rem,
        };
        let bytes = bytes.get(padding_len..).ok_or(
            ParseError {
                expected: padding_len,
                got: bytes.len(),
            }
        )?;
                
        Ok((Self {
            attribute_id,
            type_of_the_value,
            ic_attribute,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size += 2;
        size += 2;
        size += self.ic_attribute.len();
        size = roundup(size, 4);
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.attribute_id.serialize(&mut target[posn..]);
        posn += self.type_of_the_value.serialize(&mut target[posn..]);
        posn += (self.ic_attribute.len() as u16).serialize(&mut target[posn..]);
        
        let blen = self.ic_attribute.len();
        target[posn..posn + blen].copy_from_slice(&self.ic_attribute);
        posn += blen;
                
        posn = roundup(posn, 4);
        posn
    }
}
#[cfg(test)]
impl<'a> GenRandom for XicattrFr<'a> {
    fn generate() -> Self {
        Self {
            attribute_id: GenRandom::generate(),
            type_of_the_value: GenRandom::generate(),
            ic_attribute: core::iter::repeat_with(|| fastrand::u8(..)).take(fastrand::usize(..255)).collect(),
        }
    }
}
#[cfg(test)]
#[test]
fn xicattr_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = XicattrFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = XicattrFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct XimattributeFr<'a> {
    pub attribute_id: u16,
    pub value: Cow<'a, [u8]>,
}
impl<'a> Frame for XimattributeFr<'a> {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (attribute_id, bytes) = u16::parse(bytes)?;
        let (value_length, bytes) = u16::parse(bytes)?;
        
        if value_length as usize > bytes.len() {
            return Err(ParseError {
                expected: value_length as usize,
                got: bytes.len(),
            });
        }
        let (value, bytes) = bytes.split_at(value_length as usize);
        let value = Cow::Owned(value.to_vec());
                    
        
        let bytes_so_far = (bytes.as_ptr() as usize) - (_start.as_ptr() as usize);
        let padding_len = match bytes_so_far % 4 {
            0 => 0,
            rem => 4 - rem,
        };
        let bytes = bytes.get(padding_len..).ok_or(
            ParseError {
                expected: padding_len,
                got: bytes.len(),
            }
        )?;
                
        Ok((Self {
            attribute_id,
            value,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size += 2;
        size += self.value.len();
        size = roundup(size, 4);
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.attribute_id.serialize(&mut target[posn..]);
        posn += (self.value.len() as u16).serialize(&mut target[posn..]);
        
        let blen = self.value.len();
        target[posn..posn + blen].copy_from_slice(&self.value);
        posn += blen;
                
        posn = roundup(posn, 4);
        posn
    }
}
#[cfg(test)]
impl<'a> GenRandom for XimattributeFr<'a> {
    fn generate() -> Self {
        Self {
            attribute_id: GenRandom::generate(),
            value: core::iter::repeat_with(|| fastrand::u8(..)).take(fastrand::usize(..255)).collect(),
        }
    }
}
#[cfg(test)]
#[test]
fn ximattribute_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = XimattributeFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = XimattributeFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct XicattributeFr<'a> {
    pub attribute_id: u16,
    pub value: Cow<'a, [u8]>,
}
impl<'a> Frame for XicattributeFr<'a> {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (attribute_id, bytes) = u16::parse(bytes)?;
        let (value_length, bytes) = u16::parse(bytes)?;
        
        if value_length as usize > bytes.len() {
            return Err(ParseError {
                expected: value_length as usize,
                got: bytes.len(),
            });
        }
        let (value, bytes) = bytes.split_at(value_length as usize);
        let value = Cow::Owned(value.to_vec());
                    
        
        let bytes_so_far = (bytes.as_ptr() as usize) - (_start.as_ptr() as usize);
        let padding_len = match bytes_so_far % 4 {
            0 => 0,
            rem => 4 - rem,
        };
        let bytes = bytes.get(padding_len..).ok_or(
            ParseError {
                expected: padding_len,
                got: bytes.len(),
            }
        )?;
                
        Ok((Self {
            attribute_id,
            value,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size += 2;
        size += self.value.len();
        size = roundup(size, 4);
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.attribute_id.serialize(&mut target[posn..]);
        posn += (self.value.len() as u16).serialize(&mut target[posn..]);
        
        let blen = self.value.len();
        target[posn..posn + blen].copy_from_slice(&self.value);
        posn += blen;
                
        posn = roundup(posn, 4);
        posn
    }
}
#[cfg(test)]
impl<'a> GenRandom for XicattributeFr<'a> {
    fn generate() -> Self {
        Self {
            attribute_id: GenRandom::generate(),
            value: core::iter::repeat_with(|| fastrand::u8(..)).take(fastrand::usize(..255)).collect(),
        }
    }
}
#[cfg(test)]
#[test]
fn xicattribute_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = XicattributeFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = XicattributeFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,Copy,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct XimtriggerkeyFr {
    pub keysym: u32,
    pub modifier: u32,
    pub modifier_mask: u32,
}
impl Frame for XimtriggerkeyFr {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (keysym, bytes) = u32::parse(bytes)?;
        let (modifier, bytes) = u32::parse(bytes)?;
        let (modifier_mask, bytes) = u32::parse(bytes)?;
        Ok((Self {
            keysym,
            modifier,
            modifier_mask,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 4;
        size += 4;
        size += 4;
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.keysym.serialize(&mut target[posn..]);
        posn += self.modifier.serialize(&mut target[posn..]);
        posn += self.modifier_mask.serialize(&mut target[posn..]);
        posn
    }
}
#[cfg(test)]
impl GenRandom for XimtriggerkeyFr {
    fn generate() -> Self {
        Self {
            keysym: GenRandom::generate(),
            modifier: GenRandom::generate(),
            modifier_mask: GenRandom::generate(),
        }
    }
}
#[cfg(test)]
#[test]
fn ximtriggerkey_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = XimtriggerkeyFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = XimtriggerkeyFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct EncodinginfoFr<'a> {
    pub encoding_info: Cow<'a, [u8]>,
}
impl<'a> Frame for EncodinginfoFr<'a> {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (length_of_encoding_info, bytes) = u16::parse(bytes)?;
        
        if length_of_encoding_info as usize > bytes.len() {
            return Err(ParseError {
                expected: length_of_encoding_info as usize,
                got: bytes.len(),
            });
        }
        let (encoding_info, bytes) = bytes.split_at(length_of_encoding_info as usize);
        let encoding_info = Cow::Owned(encoding_info.to_vec());
                    
        
        let bytes_so_far = (bytes.as_ptr() as usize) - (_start.as_ptr() as usize);
        let padding_len = match bytes_so_far % 4 {
            0 => 0,
            rem => 4 - rem,
        };
        let bytes = bytes.get(padding_len..).ok_or(
            ParseError {
                expected: padding_len,
                got: bytes.len(),
            }
        )?;
                
        Ok((Self {
            encoding_info,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size += self.encoding_info.len();
        size = roundup(size, 4);
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += (self.encoding_info.len() as u16).serialize(&mut target[posn..]);
        
        let blen = self.encoding_info.len();
        target[posn..posn + blen].copy_from_slice(&self.encoding_info);
        posn += blen;
                
        posn = roundup(posn, 4);
        posn
    }
}
#[cfg(test)]
impl<'a> GenRandom for EncodinginfoFr<'a> {
    fn generate() -> Self {
        Self {
            encoding_info: core::iter::repeat_with(|| fastrand::u8(..)).take(fastrand::usize(..255)).collect(),
        }
    }
}
#[cfg(test)]
#[test]
fn encodinginfo_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = EncodinginfoFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = EncodinginfoFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct StrFr<'a> {
    pub string: Cow<'a, [u8]>,
}
impl<'a> Frame for StrFr<'a> {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (number_of_byte, bytes) = u8::parse(bytes)?;
        
        if number_of_byte as usize > bytes.len() {
            return Err(ParseError {
                expected: number_of_byte as usize,
                got: bytes.len(),
            });
        }
        let (string, bytes) = bytes.split_at(number_of_byte as usize);
        let string = Cow::Owned(string.to_vec());
                    
        Ok((Self {
            string,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 1;
        size += self.string.len();
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += (self.string.len() as u8).serialize(&mut target[posn..]);
        
        let blen = self.string.len();
        target[posn..posn + blen].copy_from_slice(&self.string);
        posn += blen;
                
        posn
    }
}
#[cfg(test)]
impl<'a> GenRandom for StrFr<'a> {
    fn generate() -> Self {
        Self {
            string: core::iter::repeat_with(|| fastrand::u8(..)).take(fastrand::usize(..255)).collect(),
        }
    }
}
#[cfg(test)]
#[test]
fn str_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = StrFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = StrFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct XpcsFr<'a> {
    pub string: Cow<'a, [u8]>,
}
impl<'a> Frame for XpcsFr<'a> {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (length_of_string_in_bytes, bytes) = u16::parse(bytes)?;
        
        if length_of_string_in_bytes as usize > bytes.len() {
            return Err(ParseError {
                expected: length_of_string_in_bytes as usize,
                got: bytes.len(),
            });
        }
        let (string, bytes) = bytes.split_at(length_of_string_in_bytes as usize);
        let string = Cow::Owned(string.to_vec());
                    
        
        let bytes_so_far = (bytes.as_ptr() as usize) - (_start.as_ptr() as usize);
        let padding_len = match bytes_so_far % 4 {
            0 => 0,
            rem => 4 - rem,
        };
        let bytes = bytes.get(padding_len..).ok_or(
            ParseError {
                expected: padding_len,
                got: bytes.len(),
            }
        )?;
                
        Ok((Self {
            string,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size += self.string.len();
        size = roundup(size, 4);
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += (self.string.len() as u16).serialize(&mut target[posn..]);
        
        let blen = self.string.len();
        target[posn..posn + blen].copy_from_slice(&self.string);
        posn += blen;
                
        posn = roundup(posn, 4);
        posn
    }
}
#[cfg(test)]
impl<'a> GenRandom for XpcsFr<'a> {
    fn generate() -> Self {
        Self {
            string: core::iter::repeat_with(|| fastrand::u8(..)).take(fastrand::usize(..255)).collect(),
        }
    }
}
#[cfg(test)]
#[test]
fn xpcs_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = XpcsFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = XpcsFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct ExtFr<'a> {
    pub extension_major_opcode: u16,
    pub extension_minor_opcode: u16,
    pub extension_name: Cow<'a, [u8]>,
}
impl<'a> Frame for ExtFr<'a> {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (extension_major_opcode, bytes) = u16::parse(bytes)?;
        let (extension_minor_opcode, bytes) = u16::parse(bytes)?;
        let (length_of_extension_name, bytes) = u16::parse(bytes)?;
        
        if length_of_extension_name as usize > bytes.len() {
            return Err(ParseError {
                expected: length_of_extension_name as usize,
                got: bytes.len(),
            });
        }
        let (extension_name, bytes) = bytes.split_at(length_of_extension_name as usize);
        let extension_name = Cow::Owned(extension_name.to_vec());
                    
        
        let bytes_so_far = (bytes.as_ptr() as usize) - (_start.as_ptr() as usize);
        let padding_len = match bytes_so_far % 4 {
            0 => 0,
            rem => 4 - rem,
        };
        let bytes = bytes.get(padding_len..).ok_or(
            ParseError {
                expected: padding_len,
                got: bytes.len(),
            }
        )?;
                
        Ok((Self {
            extension_major_opcode,
            extension_minor_opcode,
            extension_name,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size += 2;
        size += 2;
        size += self.extension_name.len();
        size = roundup(size, 4);
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.extension_major_opcode.serialize(&mut target[posn..]);
        posn += self.extension_minor_opcode.serialize(&mut target[posn..]);
        posn += (self.extension_name.len() as u16).serialize(&mut target[posn..]);
        
        let blen = self.extension_name.len();
        target[posn..posn + blen].copy_from_slice(&self.extension_name);
        posn += blen;
                
        posn = roundup(posn, 4);
        posn
    }
}
#[cfg(test)]
impl<'a> GenRandom for ExtFr<'a> {
    fn generate() -> Self {
        Self {
            extension_major_opcode: GenRandom::generate(),
            extension_minor_opcode: GenRandom::generate(),
            extension_name: core::iter::repeat_with(|| fastrand::u8(..)).take(fastrand::usize(..255)).collect(),
        }
    }
}
#[cfg(test)]
#[test]
fn ext_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = ExtFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = ExtFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,Copy,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct InputstyleFr {
    pub inputstyle: u32,
}
impl Frame for InputstyleFr {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (inputstyle, bytes) = u32::parse(bytes)?;
        Ok((Self {
            inputstyle,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 4;
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.inputstyle.serialize(&mut target[posn..]);
        posn
    }
}
#[cfg(test)]
impl GenRandom for InputstyleFr {
    fn generate() -> Self {
        Self {
            inputstyle: GenRandom::generate(),
        }
    }
}
#[cfg(test)]
#[test]
fn inputstyle_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = InputstyleFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = InputstyleFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,Copy,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct AttrHeadFr {
    pub attribute_id: u16,
    pub attribute_length: u16,
}
impl Frame for AttrHeadFr {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (attribute_id, bytes) = u16::parse(bytes)?;
        let (attribute_length, bytes) = u16::parse(bytes)?;
        Ok((Self {
            attribute_id,
            attribute_length,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size += 2;
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.attribute_id.serialize(&mut target[posn..]);
        posn += self.attribute_length.serialize(&mut target[posn..]);
        posn
    }
}
#[cfg(test)]
impl GenRandom for AttrHeadFr {
    fn generate() -> Self {
        Self {
            attribute_id: GenRandom::generate(),
            attribute_length: GenRandom::generate(),
        }
    }
}
#[cfg(test)]
#[test]
fn attr_head_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = AttrHeadFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = AttrHeadFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,Copy,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct ShortFr {
    pub value: u16,
}
impl Frame for ShortFr {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (value, bytes) = u16::parse(bytes)?;
        Ok((Self {
            value,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.value.serialize(&mut target[posn..]);
        posn
    }
}
#[cfg(test)]
impl GenRandom for ShortFr {
    fn generate() -> Self {
        Self {
            value: GenRandom::generate(),
        }
    }
}
#[cfg(test)]
#[test]
fn short_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = ShortFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = ShortFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,Copy,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct LongFr {
    pub value: u32,
}
impl Frame for LongFr {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (value, bytes) = u32::parse(bytes)?;
        Ok((Self {
            value,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 4;
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.value.serialize(&mut target[posn..]);
        posn
    }
}
#[cfg(test)]
impl GenRandom for LongFr {
    fn generate() -> Self {
        Self {
            value: GenRandom::generate(),
        }
    }
}
#[cfg(test)]
#[test]
fn long_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = LongFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = LongFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,Copy,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct XrectangleFr {
    pub x: u16,
    pub y: u16,
    pub width: u16,
    pub height: u16,
}
impl Frame for XrectangleFr {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (x, bytes) = u16::parse(bytes)?;
        let (y, bytes) = u16::parse(bytes)?;
        let (width, bytes) = u16::parse(bytes)?;
        let (height, bytes) = u16::parse(bytes)?;
        Ok((Self {
            x,
            y,
            width,
            height,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size += 2;
        size += 2;
        size += 2;
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.x.serialize(&mut target[posn..]);
        posn += self.y.serialize(&mut target[posn..]);
        posn += self.width.serialize(&mut target[posn..]);
        posn += self.height.serialize(&mut target[posn..]);
        posn
    }
}
#[cfg(test)]
impl GenRandom for XrectangleFr {
    fn generate() -> Self {
        Self {
            x: GenRandom::generate(),
            y: GenRandom::generate(),
            width: GenRandom::generate(),
            height: GenRandom::generate(),
        }
    }
}
#[cfg(test)]
#[test]
fn xrectangle_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = XrectangleFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = XrectangleFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,Copy,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct XpointFr {
    pub x: u16,
    pub y: u16,
}
impl Frame for XpointFr {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (x, bytes) = u16::parse(bytes)?;
        let (y, bytes) = u16::parse(bytes)?;
        Ok((Self {
            x,
            y,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size += 2;
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.x.serialize(&mut target[posn..]);
        posn += self.y.serialize(&mut target[posn..]);
        posn
    }
}
#[cfg(test)]
impl GenRandom for XpointFr {
    fn generate() -> Self {
        Self {
            x: GenRandom::generate(),
            y: GenRandom::generate(),
        }
    }
}
#[cfg(test)]
#[test]
fn xpoint_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = XpointFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = XpointFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct FontsetFr<'a> {
    pub base_font_name_list: Cow<'a, [u8]>,
}
impl<'a> Frame for FontsetFr<'a> {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (length_of_base_font_name, bytes) = u16::parse(bytes)?;
        
        if length_of_base_font_name as usize > bytes.len() {
            return Err(ParseError {
                expected: length_of_base_font_name as usize,
                got: bytes.len(),
            });
        }
        let (base_font_name_list, bytes) = bytes.split_at(length_of_base_font_name as usize);
        let base_font_name_list = Cow::Owned(base_font_name_list.to_vec());
                    
        
        let bytes_so_far = (bytes.as_ptr() as usize) - (_start.as_ptr() as usize);
        let padding_len = match bytes_so_far % 4 {
            0 => 0,
            rem => 4 - rem,
        };
        let bytes = bytes.get(padding_len..).ok_or(
            ParseError {
                expected: padding_len,
                got: bytes.len(),
            }
        )?;
                
        Ok((Self {
            base_font_name_list,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size += self.base_font_name_list.len();
        size = roundup(size, 4);
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += (self.base_font_name_list.len() as u16).serialize(&mut target[posn..]);
        
        let blen = self.base_font_name_list.len();
        target[posn..posn + blen].copy_from_slice(&self.base_font_name_list);
        posn += blen;
                
        posn = roundup(posn, 4);
        posn
    }
}
#[cfg(test)]
impl<'a> GenRandom for FontsetFr<'a> {
    fn generate() -> Self {
        Self {
            base_font_name_list: core::iter::repeat_with(|| fastrand::u8(..)).take(fastrand::usize(..255)).collect(),
        }
    }
}
#[cfg(test)]
#[test]
fn fontset_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = FontsetFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = FontsetFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct InputStylesFr {
    pub xim_style_list: Vec<InputstyleFr>,
}
impl Frame for InputStylesFr {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (field0, bytes) = u16::parse(bytes)?;
        
        let bytes_so_far = (bytes.as_ptr() as usize) - (_start.as_ptr() as usize);
        let padding_len = match bytes_so_far % 4 {
            0 => 0,
            rem => 4 - rem,
        };
        let bytes = bytes.get(padding_len..).ok_or(
            ParseError {
                expected: padding_len,
                got: bytes.len(),
            }
        )?;
                
        
        let mut xim_style_list = Vec::with_capacity(field0 as usize);
        let mut bytes = bytes;

        for _ in 0..field0 {
            let (val, rem) = InputstyleFr::parse(bytes)?;
            xim_style_list.push(val);
            bytes = rem;
        }
                
        Ok((Self {
            xim_style_list,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size = roundup(size, 4);
        size += self.xim_style_list.iter().fold(0, |acc, t| acc + t.size());
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += (self.xim_style_list.len() as u16).serialize(&mut target[posn..]);
        posn = roundup(posn, 4);
        
        for t in &self.xim_style_list {
            posn += t.serialize(&mut target[posn..]);
        }
                
        posn
    }
}
#[cfg(test)]
impl GenRandom for InputStylesFr {
    fn generate() -> Self {
        Self {
            xim_style_list: core::iter::repeat_with(GenRandom::generate).take(fastrand::usize(..255)).collect(),
        }
    }
}
#[cfg(test)]
#[test]
fn input_styles_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = InputStylesFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = InputStylesFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,Copy,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct PacketHeaderFr {
    pub major_opcode: u8,
    pub minor_opcode: u8,
    pub length: u16,
}
impl Frame for PacketHeaderFr {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (major_opcode, bytes) = u8::parse(bytes)?;
        let (minor_opcode, bytes) = u8::parse(bytes)?;
        let (length, bytes) = u16::parse(bytes)?;
        Ok((Self {
            major_opcode,
            minor_opcode,
            length,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 1;
        size += 1;
        size += 2;
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.major_opcode.serialize(&mut target[posn..]);
        posn += self.minor_opcode.serialize(&mut target[posn..]);
        posn += self.length.serialize(&mut target[posn..]);
        posn
    }
}
#[cfg(test)]
impl GenRandom for PacketHeaderFr {
    fn generate() -> Self {
        Self {
            major_opcode: GenRandom::generate(),
            minor_opcode: GenRandom::generate(),
            length: GenRandom::generate(),
        }
    }
}
#[cfg(test)]
#[test]
fn packet_header_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = PacketHeaderFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = PacketHeaderFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct ErrorFr<'a> {
    pub input_method_id: u16,
    pub input_context_id: u16,
    pub flag: u16,
    pub error_code: u16,
    pub type_of_error_detail: u16,
    pub error_detail: Cow<'a, [u8]>,
}
impl<'a> Frame for ErrorFr<'a> {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (input_method_id, bytes) = u16::parse(bytes)?;
        let (input_context_id, bytes) = u16::parse(bytes)?;
        let (flag, bytes) = u16::parse(bytes)?;
        let (error_code, bytes) = u16::parse(bytes)?;
        let (length_of_error_detail, bytes) = u16::parse(bytes)?;
        let (type_of_error_detail, bytes) = u16::parse(bytes)?;
        
        if length_of_error_detail as usize > bytes.len() {
            return Err(ParseError {
                expected: length_of_error_detail as usize,
                got: bytes.len(),
            });
        }
        let (error_detail, bytes) = bytes.split_at(length_of_error_detail as usize);
        let error_detail = Cow::Owned(error_detail.to_vec());
                    
        
        let bytes_so_far = (bytes.as_ptr() as usize) - (_start.as_ptr() as usize);
        let padding_len = match bytes_so_far % 4 {
            0 => 0,
            rem => 4 - rem,
        };
        let bytes = bytes.get(padding_len..).ok_or(
            ParseError {
                expected: padding_len,
                got: bytes.len(),
            }
        )?;
                
        Ok((Self {
            input_method_id,
            input_context_id,
            flag,
            error_code,
            type_of_error_detail,
            error_detail,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size += 2;
        size += 2;
        size += 2;
        size += 2;
        size += 2;
        size += self.error_detail.len();
        size = roundup(size, 4);
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.input_method_id.serialize(&mut target[posn..]);
        posn += self.input_context_id.serialize(&mut target[posn..]);
        posn += self.flag.serialize(&mut target[posn..]);
        posn += self.error_code.serialize(&mut target[posn..]);
        posn += (self.error_detail.len() as u16).serialize(&mut target[posn..]);
        posn += self.type_of_error_detail.serialize(&mut target[posn..]);
        
        let blen = self.error_detail.len();
        target[posn..posn + blen].copy_from_slice(&self.error_detail);
        posn += blen;
                
        posn = roundup(posn, 4);
        posn
    }
}
#[cfg(test)]
impl<'a> GenRandom for ErrorFr<'a> {
    fn generate() -> Self {
        Self {
            input_method_id: GenRandom::generate(),
            input_context_id: GenRandom::generate(),
            flag: GenRandom::generate(),
            error_code: GenRandom::generate(),
            type_of_error_detail: GenRandom::generate(),
            error_detail: core::iter::repeat_with(|| fastrand::u8(..)).take(fastrand::usize(..255)).collect(),
        }
    }
}
#[cfg(test)]
#[test]
fn error_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = ErrorFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = ErrorFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
impl<'a> From<ErrorFr<'a>> for XimFrame<'a> {
    fn from(val: ErrorFr<'a>) -> XimFrame<'a> {
        XimFrame::Error(val)
    }
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct ConnectFr<'a> {
    pub byte_order: u8,
    pub client_major_protocol_version: u16,
    pub client_minor_protocol_version: u16,
    pub client_auth_protocol_names: Vec<XpcsFr<'a>>,
}
impl<'a> Frame for ConnectFr<'a> {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (byte_order, bytes) = u8::parse(bytes)?;
        
        let bytes_so_far = (bytes.as_ptr() as usize) - (_start.as_ptr() as usize);
        let padding_len = match bytes_so_far % 2 {
            0 => 0,
            rem => 2 - rem,
        };
        let bytes = bytes.get(padding_len..).ok_or(
            ParseError {
                expected: padding_len,
                got: bytes.len(),
            }
        )?;
                
        let (client_major_protocol_version, bytes) = u16::parse(bytes)?;
        let (client_minor_protocol_version, bytes) = u16::parse(bytes)?;
        let (field4, bytes) = u16::parse(bytes)?;
        
        let mut client_auth_protocol_names = Vec::with_capacity(field4 as usize);
        let mut bytes = bytes;

        for _ in 0..field4 {
            let (val, rem) = XpcsFr::parse(bytes)?;
            client_auth_protocol_names.push(val);
            bytes = rem;
        }
                
        Ok((Self {
            byte_order,
            client_major_protocol_version,
            client_minor_protocol_version,
            client_auth_protocol_names,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 1;
        size = roundup(size, 2);
        size += 2;
        size += 2;
        size += 2;
        size += self.client_auth_protocol_names.iter().fold(0, |acc, t| acc + t.size());
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.byte_order.serialize(&mut target[posn..]);
        posn = roundup(posn, 2);
        posn += self.client_major_protocol_version.serialize(&mut target[posn..]);
        posn += self.client_minor_protocol_version.serialize(&mut target[posn..]);
        posn += (self.client_auth_protocol_names.len() as u16).serialize(&mut target[posn..]);
        
        for t in &self.client_auth_protocol_names {
            posn += t.serialize(&mut target[posn..]);
        }
                
        posn
    }
}
#[cfg(test)]
impl<'a> GenRandom for ConnectFr<'a> {
    fn generate() -> Self {
        Self {
            byte_order: GenRandom::generate(),
            client_major_protocol_version: GenRandom::generate(),
            client_minor_protocol_version: GenRandom::generate(),
            client_auth_protocol_names: core::iter::repeat_with(GenRandom::generate).take(fastrand::usize(..255)).collect(),
        }
    }
}
#[cfg(test)]
#[test]
fn connect_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = ConnectFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = ConnectFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
impl<'a> From<ConnectFr<'a>> for XimFrame<'a> {
    fn from(val: ConnectFr<'a>) -> XimFrame<'a> {
        XimFrame::Connect(val)
    }
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,Copy,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct ConnectReplyFr {
    pub server_major_protocol_version: u16,
    pub server_minor_protocol_version: u16,
}
impl Frame for ConnectReplyFr {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (server_major_protocol_version, bytes) = u16::parse(bytes)?;
        let (server_minor_protocol_version, bytes) = u16::parse(bytes)?;
        Ok((Self {
            server_major_protocol_version,
            server_minor_protocol_version,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size += 2;
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.server_major_protocol_version.serialize(&mut target[posn..]);
        posn += self.server_minor_protocol_version.serialize(&mut target[posn..]);
        posn
    }
}
#[cfg(test)]
impl GenRandom for ConnectReplyFr {
    fn generate() -> Self {
        Self {
            server_major_protocol_version: GenRandom::generate(),
            server_minor_protocol_version: GenRandom::generate(),
        }
    }
}
#[cfg(test)]
#[test]
fn connect_reply_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = ConnectReplyFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = ConnectReplyFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
impl<'a> From<ConnectReplyFr> for XimFrame<'a> {
    fn from(val: ConnectReplyFr) -> XimFrame<'a> {
        XimFrame::ConnectReply(val)
    }
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct AuthRequiredFr<'a> {
    pub auth_protocol_index: u8,
    pub auth_data2: Cow<'a, [u8]>,
}
impl<'a> Frame for AuthRequiredFr<'a> {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (auth_protocol_index, bytes) = u8::parse(bytes)?;
        let (auth_data1, bytes) = u8::parse(bytes)?;
        
        if auth_data1 as usize > bytes.len() {
            return Err(ParseError {
                expected: auth_data1 as usize,
                got: bytes.len(),
            });
        }
        let (auth_data2, bytes) = bytes.split_at(auth_data1 as usize);
        let auth_data2 = Cow::Owned(auth_data2.to_vec());
                    
        
        let bytes_so_far = (bytes.as_ptr() as usize) - (_start.as_ptr() as usize);
        let padding_len = match bytes_so_far % 4 {
            0 => 0,
            rem => 4 - rem,
        };
        let bytes = bytes.get(padding_len..).ok_or(
            ParseError {
                expected: padding_len,
                got: bytes.len(),
            }
        )?;
                
        Ok((Self {
            auth_protocol_index,
            auth_data2,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 1;
        size += 1;
        size += self.auth_data2.len();
        size = roundup(size, 4);
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.auth_protocol_index.serialize(&mut target[posn..]);
        posn += (self.auth_data2.len() as u8).serialize(&mut target[posn..]);
        
        let blen = self.auth_data2.len();
        target[posn..posn + blen].copy_from_slice(&self.auth_data2);
        posn += blen;
                
        posn = roundup(posn, 4);
        posn
    }
}
#[cfg(test)]
impl<'a> GenRandom for AuthRequiredFr<'a> {
    fn generate() -> Self {
        Self {
            auth_protocol_index: GenRandom::generate(),
            auth_data2: core::iter::repeat_with(|| fastrand::u8(..)).take(fastrand::usize(..255)).collect(),
        }
    }
}
#[cfg(test)]
#[test]
fn auth_required_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = AuthRequiredFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = AuthRequiredFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
impl<'a> From<AuthRequiredFr<'a>> for XimFrame<'a> {
    fn from(val: AuthRequiredFr<'a>) -> XimFrame<'a> {
        XimFrame::AuthRequired(val)
    }
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct AuthReplyFr<'a> {
    pub field1: Cow<'a, [u8]>,
}
impl<'a> Frame for AuthReplyFr<'a> {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (field0, bytes) = u8::parse(bytes)?;
        
        if field0 as usize > bytes.len() {
            return Err(ParseError {
                expected: field0 as usize,
                got: bytes.len(),
            });
        }
        let (field1, bytes) = bytes.split_at(field0 as usize);
        let field1 = Cow::Owned(field1.to_vec());
                    
        
        let bytes_so_far = (bytes.as_ptr() as usize) - (_start.as_ptr() as usize);
        let padding_len = match bytes_so_far % 4 {
            0 => 0,
            rem => 4 - rem,
        };
        let bytes = bytes.get(padding_len..).ok_or(
            ParseError {
                expected: padding_len,
                got: bytes.len(),
            }
        )?;
                
        Ok((Self {
            field1,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 1;
        size += self.field1.len();
        size = roundup(size, 4);
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += (self.field1.len() as u8).serialize(&mut target[posn..]);
        
        let blen = self.field1.len();
        target[posn..posn + blen].copy_from_slice(&self.field1);
        posn += blen;
                
        posn = roundup(posn, 4);
        posn
    }
}
#[cfg(test)]
impl<'a> GenRandom for AuthReplyFr<'a> {
    fn generate() -> Self {
        Self {
            field1: core::iter::repeat_with(|| fastrand::u8(..)).take(fastrand::usize(..255)).collect(),
        }
    }
}
#[cfg(test)]
#[test]
fn auth_reply_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = AuthReplyFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = AuthReplyFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
impl<'a> From<AuthReplyFr<'a>> for XimFrame<'a> {
    fn from(val: AuthReplyFr<'a>) -> XimFrame<'a> {
        XimFrame::AuthReply(val)
    }
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct AuthNextFr<'a> {
    pub auth_data2: Cow<'a, [u8]>,
}
impl<'a> Frame for AuthNextFr<'a> {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (auth_data1, bytes) = u8::parse(bytes)?;
        
        if auth_data1 as usize > bytes.len() {
            return Err(ParseError {
                expected: auth_data1 as usize,
                got: bytes.len(),
            });
        }
        let (auth_data2, bytes) = bytes.split_at(auth_data1 as usize);
        let auth_data2 = Cow::Owned(auth_data2.to_vec());
                    
        
        let bytes_so_far = (bytes.as_ptr() as usize) - (_start.as_ptr() as usize);
        let padding_len = match bytes_so_far % 4 {
            0 => 0,
            rem => 4 - rem,
        };
        let bytes = bytes.get(padding_len..).ok_or(
            ParseError {
                expected: padding_len,
                got: bytes.len(),
            }
        )?;
                
        Ok((Self {
            auth_data2,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 1;
        size += self.auth_data2.len();
        size = roundup(size, 4);
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += (self.auth_data2.len() as u8).serialize(&mut target[posn..]);
        
        let blen = self.auth_data2.len();
        target[posn..posn + blen].copy_from_slice(&self.auth_data2);
        posn += blen;
                
        posn = roundup(posn, 4);
        posn
    }
}
#[cfg(test)]
impl<'a> GenRandom for AuthNextFr<'a> {
    fn generate() -> Self {
        Self {
            auth_data2: core::iter::repeat_with(|| fastrand::u8(..)).take(fastrand::usize(..255)).collect(),
        }
    }
}
#[cfg(test)]
#[test]
fn auth_next_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = AuthNextFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = AuthNextFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
impl<'a> From<AuthNextFr<'a>> for XimFrame<'a> {
    fn from(val: AuthNextFr<'a>) -> XimFrame<'a> {
        XimFrame::AuthNext(val)
    }
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct AuthSetupFr<'a> {
    pub server_auth_protocol_names: Vec<XpcsFr<'a>>,
}
impl<'a> Frame for AuthSetupFr<'a> {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (field0, bytes) = u16::parse(bytes)?;
        
        let bytes_so_far = (bytes.as_ptr() as usize) - (_start.as_ptr() as usize);
        let padding_len = match bytes_so_far % 4 {
            0 => 0,
            rem => 4 - rem,
        };
        let bytes = bytes.get(padding_len..).ok_or(
            ParseError {
                expected: padding_len,
                got: bytes.len(),
            }
        )?;
                
        
        let mut server_auth_protocol_names = Vec::with_capacity(field0 as usize);
        let mut bytes = bytes;

        for _ in 0..field0 {
            let (val, rem) = XpcsFr::parse(bytes)?;
            server_auth_protocol_names.push(val);
            bytes = rem;
        }
                
        Ok((Self {
            server_auth_protocol_names,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size = roundup(size, 4);
        size += self.server_auth_protocol_names.iter().fold(0, |acc, t| acc + t.size());
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += (self.server_auth_protocol_names.len() as u16).serialize(&mut target[posn..]);
        posn = roundup(posn, 4);
        
        for t in &self.server_auth_protocol_names {
            posn += t.serialize(&mut target[posn..]);
        }
                
        posn
    }
}
#[cfg(test)]
impl<'a> GenRandom for AuthSetupFr<'a> {
    fn generate() -> Self {
        Self {
            server_auth_protocol_names: core::iter::repeat_with(GenRandom::generate).take(fastrand::usize(..255)).collect(),
        }
    }
}
#[cfg(test)]
#[test]
fn auth_setup_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = AuthSetupFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = AuthSetupFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
impl<'a> From<AuthSetupFr<'a>> for XimFrame<'a> {
    fn from(val: AuthSetupFr<'a>) -> XimFrame<'a> {
        XimFrame::AuthSetup(val)
    }
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,Copy,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct AuthNgFr {
}
impl Frame for AuthNgFr {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        Ok((Self {
        }, bytes))
    }
    fn size(&self) -> usize {
        0
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let _ = target;
        0
    }
}
#[cfg(test)]
impl GenRandom for AuthNgFr {
    fn generate() -> Self {
        Self {
        }
    }
}
#[cfg(test)]
#[test]
fn auth_ng_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = AuthNgFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = AuthNgFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
impl<'a> From<AuthNgFr> for XimFrame<'a> {
    fn from(val: AuthNgFr) -> XimFrame<'a> {
        XimFrame::AuthNg(val)
    }
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,Copy,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct DisconnectFr {
}
impl Frame for DisconnectFr {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        Ok((Self {
        }, bytes))
    }
    fn size(&self) -> usize {
        0
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let _ = target;
        0
    }
}
#[cfg(test)]
impl GenRandom for DisconnectFr {
    fn generate() -> Self {
        Self {
        }
    }
}
#[cfg(test)]
#[test]
fn disconnect_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = DisconnectFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = DisconnectFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
impl<'a> From<DisconnectFr> for XimFrame<'a> {
    fn from(val: DisconnectFr) -> XimFrame<'a> {
        XimFrame::Disconnect(val)
    }
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,Copy,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct DisconnectReplyFr {
}
impl Frame for DisconnectReplyFr {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        Ok((Self {
        }, bytes))
    }
    fn size(&self) -> usize {
        0
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let _ = target;
        0
    }
}
#[cfg(test)]
impl GenRandom for DisconnectReplyFr {
    fn generate() -> Self {
        Self {
        }
    }
}
#[cfg(test)]
#[test]
fn disconnect_reply_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = DisconnectReplyFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = DisconnectReplyFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
impl<'a> From<DisconnectReplyFr> for XimFrame<'a> {
    fn from(val: DisconnectReplyFr) -> XimFrame<'a> {
        XimFrame::DisconnectReply(val)
    }
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct OpenFr<'a> {
    pub field1: StrFr<'a>,
}
impl<'a> Frame for OpenFr<'a> {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (field1, bytes) = StrFr::parse(bytes)?;
        
        let bytes_so_far = (bytes.as_ptr() as usize) - (_start.as_ptr() as usize);
        let padding_len = match bytes_so_far % 4 {
            0 => 0,
            rem => 4 - rem,
        };
        let bytes = bytes.get(padding_len..).ok_or(
            ParseError {
                expected: padding_len,
                got: bytes.len(),
            }
        )?;
                
        Ok((Self {
            field1,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += self.field1.size();
        size = roundup(size, 4);
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.field1.serialize(&mut target[posn..]);
        posn = roundup(posn, 4);
        posn
    }
}
#[cfg(test)]
impl<'a> GenRandom for OpenFr<'a> {
    fn generate() -> Self {
        Self {
            field1: GenRandom::generate(),
        }
    }
}
#[cfg(test)]
#[test]
fn open_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = OpenFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = OpenFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
impl<'a> From<OpenFr<'a>> for XimFrame<'a> {
    fn from(val: OpenFr<'a>) -> XimFrame<'a> {
        XimFrame::Open(val)
    }
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct OpenReplyFr<'a> {
    pub input_method_id: u16,
    pub im_attribute_supported: Vec<XimattrFr<'a>>,
    pub ic_attribute_supported: Vec<XicattrFr<'a>>,
}
impl<'a> Frame for OpenReplyFr<'a> {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (input_method_id, bytes) = u16::parse(bytes)?;
        let (field1, bytes) = u16::parse(bytes)?;
        
        let mut im_attribute_supported = Vec::with_capacity(field1 as usize);
        let mut bytes = bytes;

        for _ in 0..field1 {
            let (val, rem) = XimattrFr::parse(bytes)?;
            im_attribute_supported.push(val);
            bytes = rem;
        }
                
        let (field5, bytes) = u16::parse(bytes)?;
        
        let bytes_so_far = (bytes.as_ptr() as usize) - (_start.as_ptr() as usize);
        let padding_len = match bytes_so_far % 4 {
            0 => 0,
            rem => 4 - rem,
        };
        let bytes = bytes.get(padding_len..).ok_or(
            ParseError {
                expected: padding_len,
                got: bytes.len(),
            }
        )?;
                
        
        let mut ic_attribute_supported = Vec::with_capacity(field5 as usize);
        let mut bytes = bytes;

        for _ in 0..field5 {
            let (val, rem) = XicattrFr::parse(bytes)?;
            ic_attribute_supported.push(val);
            bytes = rem;
        }
                
        Ok((Self {
            input_method_id,
            im_attribute_supported,
            ic_attribute_supported,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size += 2;
        size += self.im_attribute_supported.iter().fold(0, |acc, t| acc + t.size());
        size += 2;
        size = roundup(size, 4);
        size += self.ic_attribute_supported.iter().fold(0, |acc, t| acc + t.size());
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.input_method_id.serialize(&mut target[posn..]);
        posn += (self.im_attribute_supported.len() as u16).serialize(&mut target[posn..]);
        
        for t in &self.im_attribute_supported {
            posn += t.serialize(&mut target[posn..]);
        }
                
        posn += (self.ic_attribute_supported.len() as u16).serialize(&mut target[posn..]);
        posn = roundup(posn, 4);
        
        for t in &self.ic_attribute_supported {
            posn += t.serialize(&mut target[posn..]);
        }
                
        posn
    }
}
#[cfg(test)]
impl<'a> GenRandom for OpenReplyFr<'a> {
    fn generate() -> Self {
        Self {
            input_method_id: GenRandom::generate(),
            im_attribute_supported: core::iter::repeat_with(GenRandom::generate).take(fastrand::usize(..255)).collect(),
            ic_attribute_supported: core::iter::repeat_with(GenRandom::generate).take(fastrand::usize(..255)).collect(),
        }
    }
}
#[cfg(test)]
#[test]
fn open_reply_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = OpenReplyFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = OpenReplyFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
impl<'a> From<OpenReplyFr<'a>> for XimFrame<'a> {
    fn from(val: OpenReplyFr<'a>) -> XimFrame<'a> {
        XimFrame::OpenReply(val)
    }
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,Copy,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct CloseFr {
    pub input_method_id: u16,
}
impl Frame for CloseFr {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (input_method_id, bytes) = u16::parse(bytes)?;
        
        let bytes_so_far = (bytes.as_ptr() as usize) - (_start.as_ptr() as usize);
        let padding_len = match bytes_so_far % 4 {
            0 => 0,
            rem => 4 - rem,
        };
        let bytes = bytes.get(padding_len..).ok_or(
            ParseError {
                expected: padding_len,
                got: bytes.len(),
            }
        )?;
                
        Ok((Self {
            input_method_id,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size = roundup(size, 4);
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.input_method_id.serialize(&mut target[posn..]);
        posn = roundup(posn, 4);
        posn
    }
}
#[cfg(test)]
impl GenRandom for CloseFr {
    fn generate() -> Self {
        Self {
            input_method_id: GenRandom::generate(),
        }
    }
}
#[cfg(test)]
#[test]
fn close_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = CloseFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = CloseFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
impl<'a> From<CloseFr> for XimFrame<'a> {
    fn from(val: CloseFr) -> XimFrame<'a> {
        XimFrame::Close(val)
    }
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,Copy,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct CloseReplyFr {
    pub input_method_id: u16,
}
impl Frame for CloseReplyFr {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (input_method_id, bytes) = u16::parse(bytes)?;
        
        let bytes_so_far = (bytes.as_ptr() as usize) - (_start.as_ptr() as usize);
        let padding_len = match bytes_so_far % 4 {
            0 => 0,
            rem => 4 - rem,
        };
        let bytes = bytes.get(padding_len..).ok_or(
            ParseError {
                expected: padding_len,
                got: bytes.len(),
            }
        )?;
                
        Ok((Self {
            input_method_id,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size = roundup(size, 4);
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.input_method_id.serialize(&mut target[posn..]);
        posn = roundup(posn, 4);
        posn
    }
}
#[cfg(test)]
impl GenRandom for CloseReplyFr {
    fn generate() -> Self {
        Self {
            input_method_id: GenRandom::generate(),
        }
    }
}
#[cfg(test)]
#[test]
fn close_reply_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = CloseReplyFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = CloseReplyFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
impl<'a> From<CloseReplyFr> for XimFrame<'a> {
    fn from(val: CloseReplyFr) -> XimFrame<'a> {
        XimFrame::CloseReply(val)
    }
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct RegisterTriggerkeysFr {
    pub input_method_id: u16,
    pub on_keys_list: Vec<XimtriggerkeyFr>,
    pub off_keys_list: Vec<XimtriggerkeyFr>,
}
impl Frame for RegisterTriggerkeysFr {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (input_method_id, bytes) = u16::parse(bytes)?;
        
        let bytes_so_far = (bytes.as_ptr() as usize) - (_start.as_ptr() as usize);
        let padding_len = match bytes_so_far % 4 {
            0 => 0,
            rem => 4 - rem,
        };
        let bytes = bytes.get(padding_len..).ok_or(
            ParseError {
                expected: padding_len,
                got: bytes.len(),
            }
        )?;
                
        let (field2, bytes) = u32::parse(bytes)?;
        
        let mut on_keys_list = Vec::with_capacity(field2 as usize);
        let mut bytes = bytes;

        for _ in 0..field2 {
            let (val, rem) = XimtriggerkeyFr::parse(bytes)?;
            on_keys_list.push(val);
            bytes = rem;
        }
                
        let (field6, bytes) = u32::parse(bytes)?;
        
        let mut off_keys_list = Vec::with_capacity(field6 as usize);
        let mut bytes = bytes;

        for _ in 0..field6 {
            let (val, rem) = XimtriggerkeyFr::parse(bytes)?;
            off_keys_list.push(val);
            bytes = rem;
        }
                
        Ok((Self {
            input_method_id,
            on_keys_list,
            off_keys_list,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size = roundup(size, 4);
        size += 4;
        size += self.on_keys_list.iter().fold(0, |acc, t| acc + t.size());
        size += 4;
        size += self.off_keys_list.iter().fold(0, |acc, t| acc + t.size());
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.input_method_id.serialize(&mut target[posn..]);
        posn = roundup(posn, 4);
        posn += (self.on_keys_list.len() as u32).serialize(&mut target[posn..]);
        
        for t in &self.on_keys_list {
            posn += t.serialize(&mut target[posn..]);
        }
                
        posn += (self.off_keys_list.len() as u32).serialize(&mut target[posn..]);
        
        for t in &self.off_keys_list {
            posn += t.serialize(&mut target[posn..]);
        }
                
        posn
    }
}
#[cfg(test)]
impl GenRandom for RegisterTriggerkeysFr {
    fn generate() -> Self {
        Self {
            input_method_id: GenRandom::generate(),
            on_keys_list: core::iter::repeat_with(GenRandom::generate).take(fastrand::usize(..255)).collect(),
            off_keys_list: core::iter::repeat_with(GenRandom::generate).take(fastrand::usize(..255)).collect(),
        }
    }
}
#[cfg(test)]
#[test]
fn register_triggerkeys_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = RegisterTriggerkeysFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = RegisterTriggerkeysFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
impl<'a> From<RegisterTriggerkeysFr> for XimFrame<'a> {
    fn from(val: RegisterTriggerkeysFr) -> XimFrame<'a> {
        XimFrame::RegisterTriggerkeys(val)
    }
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,Copy,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct TriggerNotifyFr {
    pub input_mehotd_id: u16,
    pub input_context_id: u16,
    pub flag: u32,
    pub index_of_keys_list: u32,
    pub client_select_event_mask: u32,
}
impl Frame for TriggerNotifyFr {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (input_mehotd_id, bytes) = u16::parse(bytes)?;
        let (input_context_id, bytes) = u16::parse(bytes)?;
        let (flag, bytes) = u32::parse(bytes)?;
        let (index_of_keys_list, bytes) = u32::parse(bytes)?;
        let (client_select_event_mask, bytes) = u32::parse(bytes)?;
        Ok((Self {
            input_mehotd_id,
            input_context_id,
            flag,
            index_of_keys_list,
            client_select_event_mask,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size += 2;
        size += 4;
        size += 4;
        size += 4;
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.input_mehotd_id.serialize(&mut target[posn..]);
        posn += self.input_context_id.serialize(&mut target[posn..]);
        posn += self.flag.serialize(&mut target[posn..]);
        posn += self.index_of_keys_list.serialize(&mut target[posn..]);
        posn += self.client_select_event_mask.serialize(&mut target[posn..]);
        posn
    }
}
#[cfg(test)]
impl GenRandom for TriggerNotifyFr {
    fn generate() -> Self {
        Self {
            input_mehotd_id: GenRandom::generate(),
            input_context_id: GenRandom::generate(),
            flag: GenRandom::generate(),
            index_of_keys_list: GenRandom::generate(),
            client_select_event_mask: GenRandom::generate(),
        }
    }
}
#[cfg(test)]
#[test]
fn trigger_notify_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = TriggerNotifyFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = TriggerNotifyFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
impl<'a> From<TriggerNotifyFr> for XimFrame<'a> {
    fn from(val: TriggerNotifyFr) -> XimFrame<'a> {
        XimFrame::TriggerNotify(val)
    }
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,Copy,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct TriggerNotifyReplyFr {
    pub input_method_id: u16,
    pub input_context_id: u16,
}
impl Frame for TriggerNotifyReplyFr {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (input_method_id, bytes) = u16::parse(bytes)?;
        let (input_context_id, bytes) = u16::parse(bytes)?;
        Ok((Self {
            input_method_id,
            input_context_id,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size += 2;
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.input_method_id.serialize(&mut target[posn..]);
        posn += self.input_context_id.serialize(&mut target[posn..]);
        posn
    }
}
#[cfg(test)]
impl GenRandom for TriggerNotifyReplyFr {
    fn generate() -> Self {
        Self {
            input_method_id: GenRandom::generate(),
            input_context_id: GenRandom::generate(),
        }
    }
}
#[cfg(test)]
#[test]
fn trigger_notify_reply_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = TriggerNotifyReplyFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = TriggerNotifyReplyFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
impl<'a> From<TriggerNotifyReplyFr> for XimFrame<'a> {
    fn from(val: TriggerNotifyReplyFr) -> XimFrame<'a> {
        XimFrame::TriggerNotifyReply(val)
    }
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,Copy,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct SetEventMaskFr {
    pub input_method_id: u16,
    pub input_context_id: u16,
    pub forward_event_mask: u32,
    pub synchronous_event_mask: u32,
}
impl Frame for SetEventMaskFr {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (input_method_id, bytes) = u16::parse(bytes)?;
        let (input_context_id, bytes) = u16::parse(bytes)?;
        let (forward_event_mask, bytes) = u32::parse(bytes)?;
        let (synchronous_event_mask, bytes) = u32::parse(bytes)?;
        Ok((Self {
            input_method_id,
            input_context_id,
            forward_event_mask,
            synchronous_event_mask,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size += 2;
        size += 4;
        size += 4;
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.input_method_id.serialize(&mut target[posn..]);
        posn += self.input_context_id.serialize(&mut target[posn..]);
        posn += self.forward_event_mask.serialize(&mut target[posn..]);
        posn += self.synchronous_event_mask.serialize(&mut target[posn..]);
        posn
    }
}
#[cfg(test)]
impl GenRandom for SetEventMaskFr {
    fn generate() -> Self {
        Self {
            input_method_id: GenRandom::generate(),
            input_context_id: GenRandom::generate(),
            forward_event_mask: GenRandom::generate(),
            synchronous_event_mask: GenRandom::generate(),
        }
    }
}
#[cfg(test)]
#[test]
fn set_event_mask_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = SetEventMaskFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = SetEventMaskFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
impl<'a> From<SetEventMaskFr> for XimFrame<'a> {
    fn from(val: SetEventMaskFr) -> XimFrame<'a> {
        XimFrame::SetEventMask(val)
    }
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct EncodingNegotiationFr<'a> {
    pub input_method_id: u16,
    pub supported_list_of_encoding_in_im_library: Vec<StrFr<'a>>,
    pub field8: Vec<EncodinginfoFr<'a>>,
}
impl<'a> Frame for EncodingNegotiationFr<'a> {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (input_method_id, bytes) = u16::parse(bytes)?;
        let (field1, bytes) = u16::parse(bytes)?;
        
        let mut supported_list_of_encoding_in_im_library = Vec::with_capacity(field1 as usize);
        let mut bytes = bytes;

        for _ in 0..field1 {
            let (val, rem) = StrFr::parse(bytes)?;
            supported_list_of_encoding_in_im_library.push(val);
            bytes = rem;
        }
                
        
        let bytes_so_far = (bytes.as_ptr() as usize) - (_start.as_ptr() as usize);
        let padding_len = match bytes_so_far % 4 {
            0 => 0,
            rem => 4 - rem,
        };
        let bytes = bytes.get(padding_len..).ok_or(
            ParseError {
                expected: padding_len,
                got: bytes.len(),
            }
        )?;
                
        let (field6, bytes) = u16::parse(bytes)?;
        
        let bytes_so_far = (bytes.as_ptr() as usize) - (_start.as_ptr() as usize);
        let padding_len = match bytes_so_far % 4 {
            0 => 0,
            rem => 4 - rem,
        };
        let bytes = bytes.get(padding_len..).ok_or(
            ParseError {
                expected: padding_len,
                got: bytes.len(),
            }
        )?;
                
        
        let mut field8 = Vec::with_capacity(field6 as usize);
        let mut bytes = bytes;

        for _ in 0..field6 {
            let (val, rem) = EncodinginfoFr::parse(bytes)?;
            field8.push(val);
            bytes = rem;
        }
                
        Ok((Self {
            input_method_id,
            supported_list_of_encoding_in_im_library,
            field8,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size += 2;
        size += self.supported_list_of_encoding_in_im_library.iter().fold(0, |acc, t| acc + t.size());
        size = roundup(size, 4);
        size += 2;
        size = roundup(size, 4);
        size += self.field8.iter().fold(0, |acc, t| acc + t.size());
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.input_method_id.serialize(&mut target[posn..]);
        posn += (self.supported_list_of_encoding_in_im_library.len() as u16).serialize(&mut target[posn..]);
        
        for t in &self.supported_list_of_encoding_in_im_library {
            posn += t.serialize(&mut target[posn..]);
        }
                
        posn = roundup(posn, 4);
        posn += (self.field8.len() as u16).serialize(&mut target[posn..]);
        posn = roundup(posn, 4);
        
        for t in &self.field8 {
            posn += t.serialize(&mut target[posn..]);
        }
                
        posn
    }
}
#[cfg(test)]
impl<'a> GenRandom for EncodingNegotiationFr<'a> {
    fn generate() -> Self {
        Self {
            input_method_id: GenRandom::generate(),
            supported_list_of_encoding_in_im_library: core::iter::repeat_with(GenRandom::generate).take(fastrand::usize(..255)).collect(),
            field8: core::iter::repeat_with(GenRandom::generate).take(fastrand::usize(..255)).collect(),
        }
    }
}
#[cfg(test)]
#[test]
fn encoding_negotiation_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = EncodingNegotiationFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = EncodingNegotiationFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
impl<'a> From<EncodingNegotiationFr<'a>> for XimFrame<'a> {
    fn from(val: EncodingNegotiationFr<'a>) -> XimFrame<'a> {
        XimFrame::EncodingNegotiation(val)
    }
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,Copy,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct EncodingNegotiationReplyFr {
    pub input_method_id: u16,
    pub category_of_the_encoding_determined: u16,
    pub index_of_the_encoding_dterminated: u16,
}
impl Frame for EncodingNegotiationReplyFr {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (input_method_id, bytes) = u16::parse(bytes)?;
        let (category_of_the_encoding_determined, bytes) = u16::parse(bytes)?;
        let (index_of_the_encoding_dterminated, bytes) = u16::parse(bytes)?;
        
        let bytes_so_far = (bytes.as_ptr() as usize) - (_start.as_ptr() as usize);
        let padding_len = match bytes_so_far % 4 {
            0 => 0,
            rem => 4 - rem,
        };
        let bytes = bytes.get(padding_len..).ok_or(
            ParseError {
                expected: padding_len,
                got: bytes.len(),
            }
        )?;
                
        Ok((Self {
            input_method_id,
            category_of_the_encoding_determined,
            index_of_the_encoding_dterminated,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size += 2;
        size += 2;
        size = roundup(size, 4);
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.input_method_id.serialize(&mut target[posn..]);
        posn += self.category_of_the_encoding_determined.serialize(&mut target[posn..]);
        posn += self.index_of_the_encoding_dterminated.serialize(&mut target[posn..]);
        posn = roundup(posn, 4);
        posn
    }
}
#[cfg(test)]
impl GenRandom for EncodingNegotiationReplyFr {
    fn generate() -> Self {
        Self {
            input_method_id: GenRandom::generate(),
            category_of_the_encoding_determined: GenRandom::generate(),
            index_of_the_encoding_dterminated: GenRandom::generate(),
        }
    }
}
#[cfg(test)]
#[test]
fn encoding_negotiation_reply_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = EncodingNegotiationReplyFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = EncodingNegotiationReplyFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
impl<'a> From<EncodingNegotiationReplyFr> for XimFrame<'a> {
    fn from(val: EncodingNegotiationReplyFr) -> XimFrame<'a> {
        XimFrame::EncodingNegotiationReply(val)
    }
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct QueryExtensionFr<'a> {
    pub input_method_id: u16,
    pub extensions_supported_by_the_im_library: Vec<StrFr<'a>>,
}
impl<'a> Frame for QueryExtensionFr<'a> {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (input_method_id, bytes) = u16::parse(bytes)?;
        let (field1, bytes) = u16::parse(bytes)?;
        
        let mut extensions_supported_by_the_im_library = Vec::with_capacity(field1 as usize);
        let mut bytes = bytes;

        for _ in 0..field1 {
            let (val, rem) = StrFr::parse(bytes)?;
            extensions_supported_by_the_im_library.push(val);
            bytes = rem;
        }
                
        
        let bytes_so_far = (bytes.as_ptr() as usize) - (_start.as_ptr() as usize);
        let padding_len = match bytes_so_far % 4 {
            0 => 0,
            rem => 4 - rem,
        };
        let bytes = bytes.get(padding_len..).ok_or(
            ParseError {
                expected: padding_len,
                got: bytes.len(),
            }
        )?;
                
        Ok((Self {
            input_method_id,
            extensions_supported_by_the_im_library,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size += 2;
        size += self.extensions_supported_by_the_im_library.iter().fold(0, |acc, t| acc + t.size());
        size = roundup(size, 4);
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.input_method_id.serialize(&mut target[posn..]);
        posn += (self.extensions_supported_by_the_im_library.len() as u16).serialize(&mut target[posn..]);
        
        for t in &self.extensions_supported_by_the_im_library {
            posn += t.serialize(&mut target[posn..]);
        }
                
        posn = roundup(posn, 4);
        posn
    }
}
#[cfg(test)]
impl<'a> GenRandom for QueryExtensionFr<'a> {
    fn generate() -> Self {
        Self {
            input_method_id: GenRandom::generate(),
            extensions_supported_by_the_im_library: core::iter::repeat_with(GenRandom::generate).take(fastrand::usize(..255)).collect(),
        }
    }
}
#[cfg(test)]
#[test]
fn query_extension_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = QueryExtensionFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = QueryExtensionFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
impl<'a> From<QueryExtensionFr<'a>> for XimFrame<'a> {
    fn from(val: QueryExtensionFr<'a>) -> XimFrame<'a> {
        XimFrame::QueryExtension(val)
    }
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct QueryExtensionReplyFr<'a> {
    pub input_method_id: u16,
    pub field2: Vec<ExtFr<'a>>,
}
impl<'a> Frame for QueryExtensionReplyFr<'a> {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (input_method_id, bytes) = u16::parse(bytes)?;
        let (field1, bytes) = u16::parse(bytes)?;
        
        let mut field2 = Vec::with_capacity(field1 as usize);
        let mut bytes = bytes;

        for _ in 0..field1 {
            let (val, rem) = ExtFr::parse(bytes)?;
            field2.push(val);
            bytes = rem;
        }
                
        Ok((Self {
            input_method_id,
            field2,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size += 2;
        size += self.field2.iter().fold(0, |acc, t| acc + t.size());
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.input_method_id.serialize(&mut target[posn..]);
        posn += (self.field2.len() as u16).serialize(&mut target[posn..]);
        
        for t in &self.field2 {
            posn += t.serialize(&mut target[posn..]);
        }
                
        posn
    }
}
#[cfg(test)]
impl<'a> GenRandom for QueryExtensionReplyFr<'a> {
    fn generate() -> Self {
        Self {
            input_method_id: GenRandom::generate(),
            field2: core::iter::repeat_with(GenRandom::generate).take(fastrand::usize(..255)).collect(),
        }
    }
}
#[cfg(test)]
#[test]
fn query_extension_reply_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = QueryExtensionReplyFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = QueryExtensionReplyFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
impl<'a> From<QueryExtensionReplyFr<'a>> for XimFrame<'a> {
    fn from(val: QueryExtensionReplyFr<'a>) -> XimFrame<'a> {
        XimFrame::QueryExtensionReply(val)
    }
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct GetImValuesFr {
    pub input_method_id: u16,
    pub im_attribute_id: Vec<u16>,
}
impl Frame for GetImValuesFr {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (input_method_id, bytes) = u16::parse(bytes)?;
        let (field1, bytes) = u16::parse(bytes)?;
        
        let mut im_attribute_id = Vec::with_capacity(field1 as usize);
        let mut bytes = bytes;

        for _ in 0..field1 {
            let (val, rem) = u16::parse(bytes)?;
            im_attribute_id.push(val);
            bytes = rem;
        }
                
        
        let bytes_so_far = (bytes.as_ptr() as usize) - (_start.as_ptr() as usize);
        let padding_len = match bytes_so_far % 4 {
            0 => 0,
            rem => 4 - rem,
        };
        let bytes = bytes.get(padding_len..).ok_or(
            ParseError {
                expected: padding_len,
                got: bytes.len(),
            }
        )?;
                
        Ok((Self {
            input_method_id,
            im_attribute_id,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size += 2;
        size += self.im_attribute_id.iter().fold(0, |acc, t| acc + t.size());
        size = roundup(size, 4);
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.input_method_id.serialize(&mut target[posn..]);
        posn += (self.im_attribute_id.len() as u16).serialize(&mut target[posn..]);
        
        for t in &self.im_attribute_id {
            posn += t.serialize(&mut target[posn..]);
        }
                
        posn = roundup(posn, 4);
        posn
    }
}
#[cfg(test)]
impl GenRandom for GetImValuesFr {
    fn generate() -> Self {
        Self {
            input_method_id: GenRandom::generate(),
            im_attribute_id: core::iter::repeat_with(GenRandom::generate).take(fastrand::usize(..255)).collect(),
        }
    }
}
#[cfg(test)]
#[test]
fn get_im_values_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = GetImValuesFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = GetImValuesFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
impl<'a> From<GetImValuesFr> for XimFrame<'a> {
    fn from(val: GetImValuesFr) -> XimFrame<'a> {
        XimFrame::GetImValues(val)
    }
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct GetImValuesReplyFr<'a> {
    pub input_method_id: u16,
    pub im_attribute_returned: Vec<XimattributeFr<'a>>,
}
impl<'a> Frame for GetImValuesReplyFr<'a> {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (input_method_id, bytes) = u16::parse(bytes)?;
        let (field1, bytes) = u16::parse(bytes)?;
        
        let mut im_attribute_returned = Vec::with_capacity(field1 as usize);
        let mut bytes = bytes;

        for _ in 0..field1 {
            let (val, rem) = XimattributeFr::parse(bytes)?;
            im_attribute_returned.push(val);
            bytes = rem;
        }
                
        Ok((Self {
            input_method_id,
            im_attribute_returned,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size += 2;
        size += self.im_attribute_returned.iter().fold(0, |acc, t| acc + t.size());
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.input_method_id.serialize(&mut target[posn..]);
        posn += (self.im_attribute_returned.len() as u16).serialize(&mut target[posn..]);
        
        for t in &self.im_attribute_returned {
            posn += t.serialize(&mut target[posn..]);
        }
                
        posn
    }
}
#[cfg(test)]
impl<'a> GenRandom for GetImValuesReplyFr<'a> {
    fn generate() -> Self {
        Self {
            input_method_id: GenRandom::generate(),
            im_attribute_returned: core::iter::repeat_with(GenRandom::generate).take(fastrand::usize(..255)).collect(),
        }
    }
}
#[cfg(test)]
#[test]
fn get_im_values_reply_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = GetImValuesReplyFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = GetImValuesReplyFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
impl<'a> From<GetImValuesReplyFr<'a>> for XimFrame<'a> {
    fn from(val: GetImValuesReplyFr<'a>) -> XimFrame<'a> {
        XimFrame::GetImValuesReply(val)
    }
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct CreateIcFr<'a> {
    pub input_method_id: u16,
    pub ic_attributes: Vec<XicattributeFr<'a>>,
}
impl<'a> Frame for CreateIcFr<'a> {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (input_method_id, bytes) = u16::parse(bytes)?;
        let (field1, bytes) = u16::parse(bytes)?;
        
        let mut ic_attributes = Vec::with_capacity(field1 as usize);
        let mut bytes = bytes;

        for _ in 0..field1 {
            let (val, rem) = XicattributeFr::parse(bytes)?;
            ic_attributes.push(val);
            bytes = rem;
        }
                
        Ok((Self {
            input_method_id,
            ic_attributes,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size += 2;
        size += self.ic_attributes.iter().fold(0, |acc, t| acc + t.size());
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.input_method_id.serialize(&mut target[posn..]);
        posn += (self.ic_attributes.len() as u16).serialize(&mut target[posn..]);
        
        for t in &self.ic_attributes {
            posn += t.serialize(&mut target[posn..]);
        }
                
        posn
    }
}
#[cfg(test)]
impl<'a> GenRandom for CreateIcFr<'a> {
    fn generate() -> Self {
        Self {
            input_method_id: GenRandom::generate(),
            ic_attributes: core::iter::repeat_with(GenRandom::generate).take(fastrand::usize(..255)).collect(),
        }
    }
}
#[cfg(test)]
#[test]
fn create_ic_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = CreateIcFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = CreateIcFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
impl<'a> From<CreateIcFr<'a>> for XimFrame<'a> {
    fn from(val: CreateIcFr<'a>) -> XimFrame<'a> {
        XimFrame::CreateIc(val)
    }
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,Copy,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct CreateIcReplyFr {
    pub input_method_id: u16,
    pub input_context_id: u16,
}
impl Frame for CreateIcReplyFr {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (input_method_id, bytes) = u16::parse(bytes)?;
        let (input_context_id, bytes) = u16::parse(bytes)?;
        Ok((Self {
            input_method_id,
            input_context_id,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size += 2;
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.input_method_id.serialize(&mut target[posn..]);
        posn += self.input_context_id.serialize(&mut target[posn..]);
        posn
    }
}
#[cfg(test)]
impl GenRandom for CreateIcReplyFr {
    fn generate() -> Self {
        Self {
            input_method_id: GenRandom::generate(),
            input_context_id: GenRandom::generate(),
        }
    }
}
#[cfg(test)]
#[test]
fn create_ic_reply_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = CreateIcReplyFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = CreateIcReplyFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
impl<'a> From<CreateIcReplyFr> for XimFrame<'a> {
    fn from(val: CreateIcReplyFr) -> XimFrame<'a> {
        XimFrame::CreateIcReply(val)
    }
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,Copy,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct DestroyIcFr {
    pub input_method_id: u16,
    pub input_context_id: u16,
}
impl Frame for DestroyIcFr {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (input_method_id, bytes) = u16::parse(bytes)?;
        let (input_context_id, bytes) = u16::parse(bytes)?;
        Ok((Self {
            input_method_id,
            input_context_id,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size += 2;
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.input_method_id.serialize(&mut target[posn..]);
        posn += self.input_context_id.serialize(&mut target[posn..]);
        posn
    }
}
#[cfg(test)]
impl GenRandom for DestroyIcFr {
    fn generate() -> Self {
        Self {
            input_method_id: GenRandom::generate(),
            input_context_id: GenRandom::generate(),
        }
    }
}
#[cfg(test)]
#[test]
fn destroy_ic_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = DestroyIcFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = DestroyIcFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
impl<'a> From<DestroyIcFr> for XimFrame<'a> {
    fn from(val: DestroyIcFr) -> XimFrame<'a> {
        XimFrame::DestroyIc(val)
    }
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,Copy,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct DestroyIcReplyFr {
    pub input_method_id: u16,
    pub input_context_id: u16,
}
impl Frame for DestroyIcReplyFr {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (input_method_id, bytes) = u16::parse(bytes)?;
        let (input_context_id, bytes) = u16::parse(bytes)?;
        Ok((Self {
            input_method_id,
            input_context_id,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size += 2;
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.input_method_id.serialize(&mut target[posn..]);
        posn += self.input_context_id.serialize(&mut target[posn..]);
        posn
    }
}
#[cfg(test)]
impl GenRandom for DestroyIcReplyFr {
    fn generate() -> Self {
        Self {
            input_method_id: GenRandom::generate(),
            input_context_id: GenRandom::generate(),
        }
    }
}
#[cfg(test)]
#[test]
fn destroy_ic_reply_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = DestroyIcReplyFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = DestroyIcReplyFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
impl<'a> From<DestroyIcReplyFr> for XimFrame<'a> {
    fn from(val: DestroyIcReplyFr) -> XimFrame<'a> {
        XimFrame::DestroyIcReply(val)
    }
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct SetIcValuesFr<'a> {
    pub input_method_id: u16,
    pub input_context_id: u16,
    pub ic_attribute: Vec<XicattributeFr<'a>>,
}
impl<'a> Frame for SetIcValuesFr<'a> {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (input_method_id, bytes) = u16::parse(bytes)?;
        let (input_context_id, bytes) = u16::parse(bytes)?;
        let (field2, bytes) = u16::parse(bytes)?;
        
        let bytes_so_far = (bytes.as_ptr() as usize) - (_start.as_ptr() as usize);
        let padding_len = match bytes_so_far % 4 {
            0 => 0,
            rem => 4 - rem,
        };
        let bytes = bytes.get(padding_len..).ok_or(
            ParseError {
                expected: padding_len,
                got: bytes.len(),
            }
        )?;
                
        
        let mut ic_attribute = Vec::with_capacity(field2 as usize);
        let mut bytes = bytes;

        for _ in 0..field2 {
            let (val, rem) = XicattributeFr::parse(bytes)?;
            ic_attribute.push(val);
            bytes = rem;
        }
                
        Ok((Self {
            input_method_id,
            input_context_id,
            ic_attribute,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size += 2;
        size += 2;
        size = roundup(size, 4);
        size += self.ic_attribute.iter().fold(0, |acc, t| acc + t.size());
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.input_method_id.serialize(&mut target[posn..]);
        posn += self.input_context_id.serialize(&mut target[posn..]);
        posn += (self.ic_attribute.len() as u16).serialize(&mut target[posn..]);
        posn = roundup(posn, 4);
        
        for t in &self.ic_attribute {
            posn += t.serialize(&mut target[posn..]);
        }
                
        posn
    }
}
#[cfg(test)]
impl<'a> GenRandom for SetIcValuesFr<'a> {
    fn generate() -> Self {
        Self {
            input_method_id: GenRandom::generate(),
            input_context_id: GenRandom::generate(),
            ic_attribute: core::iter::repeat_with(GenRandom::generate).take(fastrand::usize(..255)).collect(),
        }
    }
}
#[cfg(test)]
#[test]
fn set_ic_values_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = SetIcValuesFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = SetIcValuesFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
impl<'a> From<SetIcValuesFr<'a>> for XimFrame<'a> {
    fn from(val: SetIcValuesFr<'a>) -> XimFrame<'a> {
        XimFrame::SetIcValues(val)
    }
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,Copy,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct SetIcValuesReplyFr {
    pub input_method_id: u16,
    pub input_context_id: u16,
}
impl Frame for SetIcValuesReplyFr {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (input_method_id, bytes) = u16::parse(bytes)?;
        let (input_context_id, bytes) = u16::parse(bytes)?;
        Ok((Self {
            input_method_id,
            input_context_id,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size += 2;
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.input_method_id.serialize(&mut target[posn..]);
        posn += self.input_context_id.serialize(&mut target[posn..]);
        posn
    }
}
#[cfg(test)]
impl GenRandom for SetIcValuesReplyFr {
    fn generate() -> Self {
        Self {
            input_method_id: GenRandom::generate(),
            input_context_id: GenRandom::generate(),
        }
    }
}
#[cfg(test)]
#[test]
fn set_ic_values_reply_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = SetIcValuesReplyFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = SetIcValuesReplyFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
impl<'a> From<SetIcValuesReplyFr> for XimFrame<'a> {
    fn from(val: SetIcValuesReplyFr) -> XimFrame<'a> {
        XimFrame::SetIcValuesReply(val)
    }
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct GetIcValuesFr {
    pub input_method_id: u16,
    pub input_context_id: u16,
    pub ic_attribute: Vec<u16>,
}
impl Frame for GetIcValuesFr {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (input_method_id, bytes) = u16::parse(bytes)?;
        let (input_context_id, bytes) = u16::parse(bytes)?;
        let (field2, bytes) = u16::parse(bytes)?;
        
        let mut ic_attribute = Vec::with_capacity(field2 as usize);
        let mut bytes = bytes;

        for _ in 0..field2 {
            let (val, rem) = u16::parse(bytes)?;
            ic_attribute.push(val);
            bytes = rem;
        }
                
        
        let bytes_so_far = (bytes.as_ptr() as usize) - (_start.as_ptr() as usize);
        let padding_len = match bytes_so_far % 4 {
            0 => 0,
            rem => 4 - rem,
        };
        let bytes = bytes.get(padding_len..).ok_or(
            ParseError {
                expected: padding_len,
                got: bytes.len(),
            }
        )?;
                
        Ok((Self {
            input_method_id,
            input_context_id,
            ic_attribute,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size += 2;
        size += 2;
        size += self.ic_attribute.iter().fold(0, |acc, t| acc + t.size());
        size = roundup(size, 4);
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.input_method_id.serialize(&mut target[posn..]);
        posn += self.input_context_id.serialize(&mut target[posn..]);
        posn += (self.ic_attribute.len() as u16).serialize(&mut target[posn..]);
        
        for t in &self.ic_attribute {
            posn += t.serialize(&mut target[posn..]);
        }
                
        posn = roundup(posn, 4);
        posn
    }
}
#[cfg(test)]
impl GenRandom for GetIcValuesFr {
    fn generate() -> Self {
        Self {
            input_method_id: GenRandom::generate(),
            input_context_id: GenRandom::generate(),
            ic_attribute: core::iter::repeat_with(GenRandom::generate).take(fastrand::usize(..255)).collect(),
        }
    }
}
#[cfg(test)]
#[test]
fn get_ic_values_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = GetIcValuesFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = GetIcValuesFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
impl<'a> From<GetIcValuesFr> for XimFrame<'a> {
    fn from(val: GetIcValuesFr) -> XimFrame<'a> {
        XimFrame::GetIcValues(val)
    }
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct GetIcValuesReplyFr<'a> {
    pub input_method_id: u16,
    pub input_context_id: u16,
    pub ic_attribute: Vec<XicattributeFr<'a>>,
}
impl<'a> Frame for GetIcValuesReplyFr<'a> {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (input_method_id, bytes) = u16::parse(bytes)?;
        let (input_context_id, bytes) = u16::parse(bytes)?;
        let (field2, bytes) = u16::parse(bytes)?;
        
        let bytes_so_far = (bytes.as_ptr() as usize) - (_start.as_ptr() as usize);
        let padding_len = match bytes_so_far % 4 {
            0 => 0,
            rem => 4 - rem,
        };
        let bytes = bytes.get(padding_len..).ok_or(
            ParseError {
                expected: padding_len,
                got: bytes.len(),
            }
        )?;
                
        
        let mut ic_attribute = Vec::with_capacity(field2 as usize);
        let mut bytes = bytes;

        for _ in 0..field2 {
            let (val, rem) = XicattributeFr::parse(bytes)?;
            ic_attribute.push(val);
            bytes = rem;
        }
                
        Ok((Self {
            input_method_id,
            input_context_id,
            ic_attribute,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size += 2;
        size += 2;
        size = roundup(size, 4);
        size += self.ic_attribute.iter().fold(0, |acc, t| acc + t.size());
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.input_method_id.serialize(&mut target[posn..]);
        posn += self.input_context_id.serialize(&mut target[posn..]);
        posn += (self.ic_attribute.len() as u16).serialize(&mut target[posn..]);
        posn = roundup(posn, 4);
        
        for t in &self.ic_attribute {
            posn += t.serialize(&mut target[posn..]);
        }
                
        posn
    }
}
#[cfg(test)]
impl<'a> GenRandom for GetIcValuesReplyFr<'a> {
    fn generate() -> Self {
        Self {
            input_method_id: GenRandom::generate(),
            input_context_id: GenRandom::generate(),
            ic_attribute: core::iter::repeat_with(GenRandom::generate).take(fastrand::usize(..255)).collect(),
        }
    }
}
#[cfg(test)]
#[test]
fn get_ic_values_reply_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = GetIcValuesReplyFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = GetIcValuesReplyFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
impl<'a> From<GetIcValuesReplyFr<'a>> for XimFrame<'a> {
    fn from(val: GetIcValuesReplyFr<'a>) -> XimFrame<'a> {
        XimFrame::GetIcValuesReply(val)
    }
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,Copy,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct SetIcFocusFr {
    pub input_method_id: u16,
    pub input_context_id: u16,
}
impl Frame for SetIcFocusFr {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (input_method_id, bytes) = u16::parse(bytes)?;
        let (input_context_id, bytes) = u16::parse(bytes)?;
        Ok((Self {
            input_method_id,
            input_context_id,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size += 2;
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.input_method_id.serialize(&mut target[posn..]);
        posn += self.input_context_id.serialize(&mut target[posn..]);
        posn
    }
}
#[cfg(test)]
impl GenRandom for SetIcFocusFr {
    fn generate() -> Self {
        Self {
            input_method_id: GenRandom::generate(),
            input_context_id: GenRandom::generate(),
        }
    }
}
#[cfg(test)]
#[test]
fn set_ic_focus_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = SetIcFocusFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = SetIcFocusFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
impl<'a> From<SetIcFocusFr> for XimFrame<'a> {
    fn from(val: SetIcFocusFr) -> XimFrame<'a> {
        XimFrame::SetIcFocus(val)
    }
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,Copy,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct UnsetIcFocusFr {
    pub input_method_id: u16,
    pub input_context_id: u16,
}
impl Frame for UnsetIcFocusFr {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (input_method_id, bytes) = u16::parse(bytes)?;
        let (input_context_id, bytes) = u16::parse(bytes)?;
        Ok((Self {
            input_method_id,
            input_context_id,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size += 2;
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.input_method_id.serialize(&mut target[posn..]);
        posn += self.input_context_id.serialize(&mut target[posn..]);
        posn
    }
}
#[cfg(test)]
impl GenRandom for UnsetIcFocusFr {
    fn generate() -> Self {
        Self {
            input_method_id: GenRandom::generate(),
            input_context_id: GenRandom::generate(),
        }
    }
}
#[cfg(test)]
#[test]
fn unset_ic_focus_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = UnsetIcFocusFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = UnsetIcFocusFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
impl<'a> From<UnsetIcFocusFr> for XimFrame<'a> {
    fn from(val: UnsetIcFocusFr) -> XimFrame<'a> {
        XimFrame::UnsetIcFocus(val)
    }
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,Copy,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct ForwardEventFr {
    pub input_method_id: u16,
    pub input_context_id: u16,
    pub flag: u16,
    pub sequence_number: u16,
}
impl Frame for ForwardEventFr {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (input_method_id, bytes) = u16::parse(bytes)?;
        let (input_context_id, bytes) = u16::parse(bytes)?;
        let (flag, bytes) = u16::parse(bytes)?;
        let (sequence_number, bytes) = u16::parse(bytes)?;
        Ok((Self {
            input_method_id,
            input_context_id,
            flag,
            sequence_number,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size += 2;
        size += 2;
        size += 2;
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.input_method_id.serialize(&mut target[posn..]);
        posn += self.input_context_id.serialize(&mut target[posn..]);
        posn += self.flag.serialize(&mut target[posn..]);
        posn += self.sequence_number.serialize(&mut target[posn..]);
        posn
    }
}
#[cfg(test)]
impl GenRandom for ForwardEventFr {
    fn generate() -> Self {
        Self {
            input_method_id: GenRandom::generate(),
            input_context_id: GenRandom::generate(),
            flag: GenRandom::generate(),
            sequence_number: GenRandom::generate(),
        }
    }
}
#[cfg(test)]
#[test]
fn forward_event_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = ForwardEventFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = ForwardEventFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
impl<'a> From<ForwardEventFr> for XimFrame<'a> {
    fn from(val: ForwardEventFr) -> XimFrame<'a> {
        XimFrame::ForwardEvent(val)
    }
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,Copy,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct SyncFr {
    pub input_method_id: u16,
    pub input_context_id: u16,
}
impl Frame for SyncFr {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (input_method_id, bytes) = u16::parse(bytes)?;
        let (input_context_id, bytes) = u16::parse(bytes)?;
        Ok((Self {
            input_method_id,
            input_context_id,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size += 2;
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.input_method_id.serialize(&mut target[posn..]);
        posn += self.input_context_id.serialize(&mut target[posn..]);
        posn
    }
}
#[cfg(test)]
impl GenRandom for SyncFr {
    fn generate() -> Self {
        Self {
            input_method_id: GenRandom::generate(),
            input_context_id: GenRandom::generate(),
        }
    }
}
#[cfg(test)]
#[test]
fn sync_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = SyncFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = SyncFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
impl<'a> From<SyncFr> for XimFrame<'a> {
    fn from(val: SyncFr) -> XimFrame<'a> {
        XimFrame::Sync(val)
    }
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,Copy,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct SyncReplyFr {
    pub input_method_id: u16,
    pub input_context_id: u16,
}
impl Frame for SyncReplyFr {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (input_method_id, bytes) = u16::parse(bytes)?;
        let (input_context_id, bytes) = u16::parse(bytes)?;
        Ok((Self {
            input_method_id,
            input_context_id,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size += 2;
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.input_method_id.serialize(&mut target[posn..]);
        posn += self.input_context_id.serialize(&mut target[posn..]);
        posn
    }
}
#[cfg(test)]
impl GenRandom for SyncReplyFr {
    fn generate() -> Self {
        Self {
            input_method_id: GenRandom::generate(),
            input_context_id: GenRandom::generate(),
        }
    }
}
#[cfg(test)]
#[test]
fn sync_reply_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = SyncReplyFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = SyncReplyFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
impl<'a> From<SyncReplyFr> for XimFrame<'a> {
    fn from(val: SyncReplyFr) -> XimFrame<'a> {
        XimFrame::SyncReply(val)
    }
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct CommitFr<'a> {
    pub input_method_id: u16,
    pub input_context_id: u16,
    pub flag: u16,
    pub committed_string: Cow<'a, [u8]>,
    pub keysym: Vec<u32>,
}
impl<'a> Frame for CommitFr<'a> {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (input_method_id, bytes) = u16::parse(bytes)?;
        let (input_context_id, bytes) = u16::parse(bytes)?;
        let (flag, bytes) = u16::parse(bytes)?;
        let (byte_length_of_committed_string, bytes) = u16::parse(bytes)?;
        
        if byte_length_of_committed_string as usize > bytes.len() {
            return Err(ParseError {
                expected: byte_length_of_committed_string as usize,
                got: bytes.len(),
            });
        }
        let (committed_string, bytes) = bytes.split_at(byte_length_of_committed_string as usize);
        let committed_string = Cow::Owned(committed_string.to_vec());
                    
        
        let bytes_so_far = (bytes.as_ptr() as usize) - (_start.as_ptr() as usize);
        let padding_len = match bytes_so_far % 4 {
            0 => 0,
            rem => 4 - rem,
        };
        let bytes = bytes.get(padding_len..).ok_or(
            ParseError {
                expected: padding_len,
                got: bytes.len(),
            }
        )?;
                
        let (field6, bytes) = u16::parse(bytes)?;
        
        let mut keysym = Vec::with_capacity(field6 as usize);
        let mut bytes = bytes;

        for _ in 0..field6 {
            let (val, rem) = u32::parse(bytes)?;
            keysym.push(val);
            bytes = rem;
        }
                
        
        let bytes_so_far = (bytes.as_ptr() as usize) - (_start.as_ptr() as usize);
        let padding_len = match bytes_so_far % 4 {
            0 => 0,
            rem => 4 - rem,
        };
        let bytes = bytes.get(padding_len..).ok_or(
            ParseError {
                expected: padding_len,
                got: bytes.len(),
            }
        )?;
                
        Ok((Self {
            input_method_id,
            input_context_id,
            flag,
            committed_string,
            keysym,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size += 2;
        size += 2;
        size += 2;
        size += self.committed_string.len();
        size = roundup(size, 4);
        size += 2;
        size += self.keysym.iter().fold(0, |acc, t| acc + t.size());
        size = roundup(size, 4);
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.input_method_id.serialize(&mut target[posn..]);
        posn += self.input_context_id.serialize(&mut target[posn..]);
        posn += self.flag.serialize(&mut target[posn..]);
        posn += (self.committed_string.len() as u16).serialize(&mut target[posn..]);
        
        let blen = self.committed_string.len();
        target[posn..posn + blen].copy_from_slice(&self.committed_string);
        posn += blen;
                
        posn = roundup(posn, 4);
        posn += (self.keysym.len() as u16).serialize(&mut target[posn..]);
        
        for t in &self.keysym {
            posn += t.serialize(&mut target[posn..]);
        }
                
        posn = roundup(posn, 4);
        posn
    }
}
#[cfg(test)]
impl<'a> GenRandom for CommitFr<'a> {
    fn generate() -> Self {
        Self {
            input_method_id: GenRandom::generate(),
            input_context_id: GenRandom::generate(),
            flag: GenRandom::generate(),
            committed_string: core::iter::repeat_with(|| fastrand::u8(..)).take(fastrand::usize(..255)).collect(),
            keysym: core::iter::repeat_with(GenRandom::generate).take(fastrand::usize(..255)).collect(),
        }
    }
}
#[cfg(test)]
#[test]
fn commit_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = CommitFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = CommitFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
impl<'a> From<CommitFr<'a>> for XimFrame<'a> {
    fn from(val: CommitFr<'a>) -> XimFrame<'a> {
        XimFrame::Commit(val)
    }
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct CommitCharsFr<'a> {
    pub input_method_id: u16,
    pub input_context_id: u16,
    pub flag: u16,
    pub committed_string: Cow<'a, [u8]>,
}
impl<'a> Frame for CommitCharsFr<'a> {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (input_method_id, bytes) = u16::parse(bytes)?;
        let (input_context_id, bytes) = u16::parse(bytes)?;
        let (flag, bytes) = u16::parse(bytes)?;
        let (byte_length_of_committed_string, bytes) = u16::parse(bytes)?;
        
        if byte_length_of_committed_string as usize > bytes.len() {
            return Err(ParseError {
                expected: byte_length_of_committed_string as usize,
                got: bytes.len(),
            });
        }
        let (committed_string, bytes) = bytes.split_at(byte_length_of_committed_string as usize);
        let committed_string = Cow::Owned(committed_string.to_vec());
                    
        
        let bytes_so_far = (bytes.as_ptr() as usize) - (_start.as_ptr() as usize);
        let padding_len = match bytes_so_far % 4 {
            0 => 0,
            rem => 4 - rem,
        };
        let bytes = bytes.get(padding_len..).ok_or(
            ParseError {
                expected: padding_len,
                got: bytes.len(),
            }
        )?;
                
        Ok((Self {
            input_method_id,
            input_context_id,
            flag,
            committed_string,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size += 2;
        size += 2;
        size += 2;
        size += self.committed_string.len();
        size = roundup(size, 4);
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.input_method_id.serialize(&mut target[posn..]);
        posn += self.input_context_id.serialize(&mut target[posn..]);
        posn += self.flag.serialize(&mut target[posn..]);
        posn += (self.committed_string.len() as u16).serialize(&mut target[posn..]);
        
        let blen = self.committed_string.len();
        target[posn..posn + blen].copy_from_slice(&self.committed_string);
        posn += blen;
                
        posn = roundup(posn, 4);
        posn
    }
}
#[cfg(test)]
impl<'a> GenRandom for CommitCharsFr<'a> {
    fn generate() -> Self {
        Self {
            input_method_id: GenRandom::generate(),
            input_context_id: GenRandom::generate(),
            flag: GenRandom::generate(),
            committed_string: core::iter::repeat_with(|| fastrand::u8(..)).take(fastrand::usize(..255)).collect(),
        }
    }
}
#[cfg(test)]
#[test]
fn commit_chars_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = CommitCharsFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = CommitCharsFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct CommitBothFr<'a> {
    pub input_method_id: u16,
    pub input_context_id: u16,
    pub flag: u16,
    pub keysym: u32,
    pub committed_string: Cow<'a, [u8]>,
}
impl<'a> Frame for CommitBothFr<'a> {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (input_method_id, bytes) = u16::parse(bytes)?;
        let (input_context_id, bytes) = u16::parse(bytes)?;
        let (flag, bytes) = u16::parse(bytes)?;
        
        let bytes_so_far = (bytes.as_ptr() as usize) - (_start.as_ptr() as usize);
        let padding_len = match bytes_so_far % 4 {
            0 => 0,
            rem => 4 - rem,
        };
        let bytes = bytes.get(padding_len..).ok_or(
            ParseError {
                expected: padding_len,
                got: bytes.len(),
            }
        )?;
                
        let (keysym, bytes) = u32::parse(bytes)?;
        let (byte_length_of_committed_string, bytes) = u16::parse(bytes)?;
        
        if byte_length_of_committed_string as usize > bytes.len() {
            return Err(ParseError {
                expected: byte_length_of_committed_string as usize,
                got: bytes.len(),
            });
        }
        let (committed_string, bytes) = bytes.split_at(byte_length_of_committed_string as usize);
        let committed_string = Cow::Owned(committed_string.to_vec());
                    
        
        let bytes_so_far = (bytes.as_ptr() as usize) - (_start.as_ptr() as usize);
        let padding_len = match bytes_so_far % 4 {
            0 => 0,
            rem => 4 - rem,
        };
        let bytes = bytes.get(padding_len..).ok_or(
            ParseError {
                expected: padding_len,
                got: bytes.len(),
            }
        )?;
                
        Ok((Self {
            input_method_id,
            input_context_id,
            flag,
            keysym,
            committed_string,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size += 2;
        size += 2;
        size = roundup(size, 4);
        size += 4;
        size += 2;
        size += self.committed_string.len();
        size = roundup(size, 4);
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.input_method_id.serialize(&mut target[posn..]);
        posn += self.input_context_id.serialize(&mut target[posn..]);
        posn += self.flag.serialize(&mut target[posn..]);
        posn = roundup(posn, 4);
        posn += self.keysym.serialize(&mut target[posn..]);
        posn += (self.committed_string.len() as u16).serialize(&mut target[posn..]);
        
        let blen = self.committed_string.len();
        target[posn..posn + blen].copy_from_slice(&self.committed_string);
        posn += blen;
                
        posn = roundup(posn, 4);
        posn
    }
}
#[cfg(test)]
impl<'a> GenRandom for CommitBothFr<'a> {
    fn generate() -> Self {
        Self {
            input_method_id: GenRandom::generate(),
            input_context_id: GenRandom::generate(),
            flag: GenRandom::generate(),
            keysym: GenRandom::generate(),
            committed_string: core::iter::repeat_with(|| fastrand::u8(..)).take(fastrand::usize(..255)).collect(),
        }
    }
}
#[cfg(test)]
#[test]
fn commit_both_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = CommitBothFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = CommitBothFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,Copy,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct ResetIcFr {
    pub input_method_id: u16,
    pub input_context_id: u16,
}
impl Frame for ResetIcFr {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (input_method_id, bytes) = u16::parse(bytes)?;
        let (input_context_id, bytes) = u16::parse(bytes)?;
        Ok((Self {
            input_method_id,
            input_context_id,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size += 2;
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.input_method_id.serialize(&mut target[posn..]);
        posn += self.input_context_id.serialize(&mut target[posn..]);
        posn
    }
}
#[cfg(test)]
impl GenRandom for ResetIcFr {
    fn generate() -> Self {
        Self {
            input_method_id: GenRandom::generate(),
            input_context_id: GenRandom::generate(),
        }
    }
}
#[cfg(test)]
#[test]
fn reset_ic_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = ResetIcFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = ResetIcFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
impl<'a> From<ResetIcFr> for XimFrame<'a> {
    fn from(val: ResetIcFr) -> XimFrame<'a> {
        XimFrame::ResetIc(val)
    }
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct ResetIcReplyFr<'a> {
    pub input_method_id: u16,
    pub input_context_id: u16,
    pub committed_string: Cow<'a, [u8]>,
}
impl<'a> Frame for ResetIcReplyFr<'a> {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (input_method_id, bytes) = u16::parse(bytes)?;
        let (input_context_id, bytes) = u16::parse(bytes)?;
        let (byte_length_of_committed_string, bytes) = u16::parse(bytes)?;
        
        if byte_length_of_committed_string as usize > bytes.len() {
            return Err(ParseError {
                expected: byte_length_of_committed_string as usize,
                got: bytes.len(),
            });
        }
        let (committed_string, bytes) = bytes.split_at(byte_length_of_committed_string as usize);
        let committed_string = Cow::Owned(committed_string.to_vec());
                    
        
        let bytes_so_far = (bytes.as_ptr() as usize) - (_start.as_ptr() as usize);
        let padding_len = match bytes_so_far % 4 {
            0 => 0,
            rem => 4 - rem,
        };
        let bytes = bytes.get(padding_len..).ok_or(
            ParseError {
                expected: padding_len,
                got: bytes.len(),
            }
        )?;
                
        Ok((Self {
            input_method_id,
            input_context_id,
            committed_string,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size += 2;
        size += 2;
        size += self.committed_string.len();
        size = roundup(size, 4);
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.input_method_id.serialize(&mut target[posn..]);
        posn += self.input_context_id.serialize(&mut target[posn..]);
        posn += (self.committed_string.len() as u16).serialize(&mut target[posn..]);
        
        let blen = self.committed_string.len();
        target[posn..posn + blen].copy_from_slice(&self.committed_string);
        posn += blen;
                
        posn = roundup(posn, 4);
        posn
    }
}
#[cfg(test)]
impl<'a> GenRandom for ResetIcReplyFr<'a> {
    fn generate() -> Self {
        Self {
            input_method_id: GenRandom::generate(),
            input_context_id: GenRandom::generate(),
            committed_string: core::iter::repeat_with(|| fastrand::u8(..)).take(fastrand::usize(..255)).collect(),
        }
    }
}
#[cfg(test)]
#[test]
fn reset_ic_reply_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = ResetIcReplyFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = ResetIcReplyFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
impl<'a> From<ResetIcReplyFr<'a>> for XimFrame<'a> {
    fn from(val: ResetIcReplyFr<'a>) -> XimFrame<'a> {
        XimFrame::ResetIcReply(val)
    }
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,Copy,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct GeometryFr {
    pub input_method_id: u16,
    pub input_context_id: u16,
}
impl Frame for GeometryFr {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (input_method_id, bytes) = u16::parse(bytes)?;
        let (input_context_id, bytes) = u16::parse(bytes)?;
        Ok((Self {
            input_method_id,
            input_context_id,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size += 2;
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.input_method_id.serialize(&mut target[posn..]);
        posn += self.input_context_id.serialize(&mut target[posn..]);
        posn
    }
}
#[cfg(test)]
impl GenRandom for GeometryFr {
    fn generate() -> Self {
        Self {
            input_method_id: GenRandom::generate(),
            input_context_id: GenRandom::generate(),
        }
    }
}
#[cfg(test)]
#[test]
fn geometry_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = GeometryFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = GeometryFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
impl<'a> From<GeometryFr> for XimFrame<'a> {
    fn from(val: GeometryFr) -> XimFrame<'a> {
        XimFrame::Geometry(val)
    }
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct StrConversionFr<'a> {
    pub input_method_id: u16,
    pub input_context_id: u16,
    pub xim_string_conversion_position: u32,
    pub xim_string_conversion_type: u32,
    pub xim_string_conversion_operation: u32,
    pub field5: u16,
    pub string: Cow<'a, [u8]>,
}
impl<'a> Frame for StrConversionFr<'a> {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (input_method_id, bytes) = u16::parse(bytes)?;
        let (input_context_id, bytes) = u16::parse(bytes)?;
        let (xim_string_conversion_position, bytes) = u32::parse(bytes)?;
        let (xim_string_conversion_type, bytes) = u32::parse(bytes)?;
        let (xim_string_conversion_operation, bytes) = u32::parse(bytes)?;
        let (field5, bytes) = u16::parse(bytes)?;
        let (field6, bytes) = u16::parse(bytes)?;
        
        if field6 as usize > bytes.len() {
            return Err(ParseError {
                expected: field6 as usize,
                got: bytes.len(),
            });
        }
        let (string, bytes) = bytes.split_at(field6 as usize);
        let string = Cow::Owned(string.to_vec());
                    
        
        let bytes_so_far = (bytes.as_ptr() as usize) - (_start.as_ptr() as usize);
        let padding_len = match bytes_so_far % 4 {
            0 => 0,
            rem => 4 - rem,
        };
        let bytes = bytes.get(padding_len..).ok_or(
            ParseError {
                expected: padding_len,
                got: bytes.len(),
            }
        )?;
                
        Ok((Self {
            input_method_id,
            input_context_id,
            xim_string_conversion_position,
            xim_string_conversion_type,
            xim_string_conversion_operation,
            field5,
            string,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size += 2;
        size += 4;
        size += 4;
        size += 4;
        size += 2;
        size += 2;
        size += self.string.len();
        size = roundup(size, 4);
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.input_method_id.serialize(&mut target[posn..]);
        posn += self.input_context_id.serialize(&mut target[posn..]);
        posn += self.xim_string_conversion_position.serialize(&mut target[posn..]);
        posn += self.xim_string_conversion_type.serialize(&mut target[posn..]);
        posn += self.xim_string_conversion_operation.serialize(&mut target[posn..]);
        posn += self.field5.serialize(&mut target[posn..]);
        posn += (self.string.len() as u16).serialize(&mut target[posn..]);
        
        let blen = self.string.len();
        target[posn..posn + blen].copy_from_slice(&self.string);
        posn += blen;
                
        posn = roundup(posn, 4);
        posn
    }
}
#[cfg(test)]
impl<'a> GenRandom for StrConversionFr<'a> {
    fn generate() -> Self {
        Self {
            input_method_id: GenRandom::generate(),
            input_context_id: GenRandom::generate(),
            xim_string_conversion_position: GenRandom::generate(),
            xim_string_conversion_type: GenRandom::generate(),
            xim_string_conversion_operation: GenRandom::generate(),
            field5: GenRandom::generate(),
            string: core::iter::repeat_with(|| fastrand::u8(..)).take(fastrand::usize(..255)).collect(),
        }
    }
}
#[cfg(test)]
#[test]
fn str_conversion_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = StrConversionFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = StrConversionFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
impl<'a> From<StrConversionFr<'a>> for XimFrame<'a> {
    fn from(val: StrConversionFr<'a>) -> XimFrame<'a> {
        XimFrame::StrConversion(val)
    }
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct StrConversionReplyFr<'a> {
    pub input_method_id: u16,
    pub input_context_id: u16,
    pub xim_string_conversion_feedback: u32,
    pub retrieved_string: Cow<'a, [u8]>,
    pub feedback_array: Vec<u32>,
}
impl<'a> Frame for StrConversionReplyFr<'a> {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (input_method_id, bytes) = u16::parse(bytes)?;
        let (input_context_id, bytes) = u16::parse(bytes)?;
        let (xim_string_conversion_feedback, bytes) = u32::parse(bytes)?;
        let (length_of_the_retrieved_string, bytes) = u16::parse(bytes)?;
        
        if length_of_the_retrieved_string as usize > bytes.len() {
            return Err(ParseError {
                expected: length_of_the_retrieved_string as usize,
                got: bytes.len(),
            });
        }
        let (retrieved_string, bytes) = bytes.split_at(length_of_the_retrieved_string as usize);
        let retrieved_string = Cow::Owned(retrieved_string.to_vec());
                    
        
        let bytes_so_far = (bytes.as_ptr() as usize) - (_start.as_ptr() as usize);
        let padding_len = match bytes_so_far % 4 {
            0 => 0,
            rem => 4 - rem,
        };
        let bytes = bytes.get(padding_len..).ok_or(
            ParseError {
                expected: padding_len,
                got: bytes.len(),
            }
        )?;
                
        let (field6, bytes) = u16::parse(bytes)?;
        
        let bytes_so_far = (bytes.as_ptr() as usize) - (_start.as_ptr() as usize);
        let padding_len = match bytes_so_far % 4 {
            0 => 0,
            rem => 4 - rem,
        };
        let bytes = bytes.get(padding_len..).ok_or(
            ParseError {
                expected: padding_len,
                got: bytes.len(),
            }
        )?;
                
        
        let mut feedback_array = Vec::with_capacity(field6 as usize);
        let mut bytes = bytes;

        for _ in 0..field6 {
            let (val, rem) = u32::parse(bytes)?;
            feedback_array.push(val);
            bytes = rem;
        }
                
        Ok((Self {
            input_method_id,
            input_context_id,
            xim_string_conversion_feedback,
            retrieved_string,
            feedback_array,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size += 2;
        size += 4;
        size += 2;
        size += self.retrieved_string.len();
        size = roundup(size, 4);
        size += 2;
        size = roundup(size, 4);
        size += self.feedback_array.iter().fold(0, |acc, t| acc + t.size());
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.input_method_id.serialize(&mut target[posn..]);
        posn += self.input_context_id.serialize(&mut target[posn..]);
        posn += self.xim_string_conversion_feedback.serialize(&mut target[posn..]);
        posn += (self.retrieved_string.len() as u16).serialize(&mut target[posn..]);
        
        let blen = self.retrieved_string.len();
        target[posn..posn + blen].copy_from_slice(&self.retrieved_string);
        posn += blen;
                
        posn = roundup(posn, 4);
        posn += (self.feedback_array.len() as u16).serialize(&mut target[posn..]);
        posn = roundup(posn, 4);
        
        for t in &self.feedback_array {
            posn += t.serialize(&mut target[posn..]);
        }
                
        posn
    }
}
#[cfg(test)]
impl<'a> GenRandom for StrConversionReplyFr<'a> {
    fn generate() -> Self {
        Self {
            input_method_id: GenRandom::generate(),
            input_context_id: GenRandom::generate(),
            xim_string_conversion_feedback: GenRandom::generate(),
            retrieved_string: core::iter::repeat_with(|| fastrand::u8(..)).take(fastrand::usize(..255)).collect(),
            feedback_array: core::iter::repeat_with(GenRandom::generate).take(fastrand::usize(..255)).collect(),
        }
    }
}
#[cfg(test)]
#[test]
fn str_conversion_reply_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = StrConversionReplyFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = StrConversionReplyFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
impl<'a> From<StrConversionReplyFr<'a>> for XimFrame<'a> {
    fn from(val: StrConversionReplyFr<'a>) -> XimFrame<'a> {
        XimFrame::StrConversionReply(val)
    }
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,Copy,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct PreeditStartFr {
    pub input_method_id: u16,
    pub input_context_id: u16,
}
impl Frame for PreeditStartFr {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (input_method_id, bytes) = u16::parse(bytes)?;
        let (input_context_id, bytes) = u16::parse(bytes)?;
        Ok((Self {
            input_method_id,
            input_context_id,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size += 2;
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.input_method_id.serialize(&mut target[posn..]);
        posn += self.input_context_id.serialize(&mut target[posn..]);
        posn
    }
}
#[cfg(test)]
impl GenRandom for PreeditStartFr {
    fn generate() -> Self {
        Self {
            input_method_id: GenRandom::generate(),
            input_context_id: GenRandom::generate(),
        }
    }
}
#[cfg(test)]
#[test]
fn preedit_start_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = PreeditStartFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = PreeditStartFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
impl<'a> From<PreeditStartFr> for XimFrame<'a> {
    fn from(val: PreeditStartFr) -> XimFrame<'a> {
        XimFrame::PreeditStart(val)
    }
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,Copy,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct PreeditStartReplyFr {
    pub input_method_id: u16,
    pub input_context_id: u16,
    pub return_value: u32,
}
impl Frame for PreeditStartReplyFr {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (input_method_id, bytes) = u16::parse(bytes)?;
        let (input_context_id, bytes) = u16::parse(bytes)?;
        let (return_value, bytes) = u32::parse(bytes)?;
        Ok((Self {
            input_method_id,
            input_context_id,
            return_value,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size += 2;
        size += 4;
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.input_method_id.serialize(&mut target[posn..]);
        posn += self.input_context_id.serialize(&mut target[posn..]);
        posn += self.return_value.serialize(&mut target[posn..]);
        posn
    }
}
#[cfg(test)]
impl GenRandom for PreeditStartReplyFr {
    fn generate() -> Self {
        Self {
            input_method_id: GenRandom::generate(),
            input_context_id: GenRandom::generate(),
            return_value: GenRandom::generate(),
        }
    }
}
#[cfg(test)]
#[test]
fn preedit_start_reply_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = PreeditStartReplyFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = PreeditStartReplyFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
impl<'a> From<PreeditStartReplyFr> for XimFrame<'a> {
    fn from(val: PreeditStartReplyFr) -> XimFrame<'a> {
        XimFrame::PreeditStartReply(val)
    }
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct PreeditDrawFr<'a> {
    pub input_method_id: u16,
    pub input_context_id: u16,
    pub caret: u32,
    pub chg_first: u32,
    pub chg_length: u32,
    pub status: u32,
    pub preedit_string: Cow<'a, [u8]>,
    pub feedback_array: Vec<u32>,
}
impl<'a> Frame for PreeditDrawFr<'a> {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (input_method_id, bytes) = u16::parse(bytes)?;
        let (input_context_id, bytes) = u16::parse(bytes)?;
        let (caret, bytes) = u32::parse(bytes)?;
        let (chg_first, bytes) = u32::parse(bytes)?;
        let (chg_length, bytes) = u32::parse(bytes)?;
        let (status, bytes) = u32::parse(bytes)?;
        let (length_of_preedit_string, bytes) = u16::parse(bytes)?;
        
        if length_of_preedit_string as usize > bytes.len() {
            return Err(ParseError {
                expected: length_of_preedit_string as usize,
                got: bytes.len(),
            });
        }
        let (preedit_string, bytes) = bytes.split_at(length_of_preedit_string as usize);
        let preedit_string = Cow::Owned(preedit_string.to_vec());
                    
        
        let bytes_so_far = (bytes.as_ptr() as usize) - (_start.as_ptr() as usize);
        let padding_len = match bytes_so_far % 4 {
            0 => 0,
            rem => 4 - rem,
        };
        let bytes = bytes.get(padding_len..).ok_or(
            ParseError {
                expected: padding_len,
                got: bytes.len(),
            }
        )?;
                
        let (field9, bytes) = u16::parse(bytes)?;
        
        let bytes_so_far = (bytes.as_ptr() as usize) - (_start.as_ptr() as usize);
        let padding_len = match bytes_so_far % 4 {
            0 => 0,
            rem => 4 - rem,
        };
        let bytes = bytes.get(padding_len..).ok_or(
            ParseError {
                expected: padding_len,
                got: bytes.len(),
            }
        )?;
                
        
        let mut feedback_array = Vec::with_capacity(field9 as usize);
        let mut bytes = bytes;

        for _ in 0..field9 {
            let (val, rem) = u32::parse(bytes)?;
            feedback_array.push(val);
            bytes = rem;
        }
                
        Ok((Self {
            input_method_id,
            input_context_id,
            caret,
            chg_first,
            chg_length,
            status,
            preedit_string,
            feedback_array,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size += 2;
        size += 4;
        size += 4;
        size += 4;
        size += 4;
        size += 2;
        size += self.preedit_string.len();
        size = roundup(size, 4);
        size += 2;
        size = roundup(size, 4);
        size += self.feedback_array.iter().fold(0, |acc, t| acc + t.size());
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.input_method_id.serialize(&mut target[posn..]);
        posn += self.input_context_id.serialize(&mut target[posn..]);
        posn += self.caret.serialize(&mut target[posn..]);
        posn += self.chg_first.serialize(&mut target[posn..]);
        posn += self.chg_length.serialize(&mut target[posn..]);
        posn += self.status.serialize(&mut target[posn..]);
        posn += (self.preedit_string.len() as u16).serialize(&mut target[posn..]);
        
        let blen = self.preedit_string.len();
        target[posn..posn + blen].copy_from_slice(&self.preedit_string);
        posn += blen;
                
        posn = roundup(posn, 4);
        posn += (self.feedback_array.len() as u16).serialize(&mut target[posn..]);
        posn = roundup(posn, 4);
        
        for t in &self.feedback_array {
            posn += t.serialize(&mut target[posn..]);
        }
                
        posn
    }
}
#[cfg(test)]
impl<'a> GenRandom for PreeditDrawFr<'a> {
    fn generate() -> Self {
        Self {
            input_method_id: GenRandom::generate(),
            input_context_id: GenRandom::generate(),
            caret: GenRandom::generate(),
            chg_first: GenRandom::generate(),
            chg_length: GenRandom::generate(),
            status: GenRandom::generate(),
            preedit_string: core::iter::repeat_with(|| fastrand::u8(..)).take(fastrand::usize(..255)).collect(),
            feedback_array: core::iter::repeat_with(GenRandom::generate).take(fastrand::usize(..255)).collect(),
        }
    }
}
#[cfg(test)]
#[test]
fn preedit_draw_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = PreeditDrawFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = PreeditDrawFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
impl<'a> From<PreeditDrawFr<'a>> for XimFrame<'a> {
    fn from(val: PreeditDrawFr<'a>) -> XimFrame<'a> {
        XimFrame::PreeditDraw(val)
    }
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,Copy,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct PreeditCaretFr {
    pub input_method_id: u16,
    pub input_context_id: u16,
    pub position: u32,
    pub direction: u32,
    pub style: u32,
}
impl Frame for PreeditCaretFr {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (input_method_id, bytes) = u16::parse(bytes)?;
        let (input_context_id, bytes) = u16::parse(bytes)?;
        let (position, bytes) = u32::parse(bytes)?;
        let (direction, bytes) = u32::parse(bytes)?;
        let (style, bytes) = u32::parse(bytes)?;
        Ok((Self {
            input_method_id,
            input_context_id,
            position,
            direction,
            style,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size += 2;
        size += 4;
        size += 4;
        size += 4;
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.input_method_id.serialize(&mut target[posn..]);
        posn += self.input_context_id.serialize(&mut target[posn..]);
        posn += self.position.serialize(&mut target[posn..]);
        posn += self.direction.serialize(&mut target[posn..]);
        posn += self.style.serialize(&mut target[posn..]);
        posn
    }
}
#[cfg(test)]
impl GenRandom for PreeditCaretFr {
    fn generate() -> Self {
        Self {
            input_method_id: GenRandom::generate(),
            input_context_id: GenRandom::generate(),
            position: GenRandom::generate(),
            direction: GenRandom::generate(),
            style: GenRandom::generate(),
        }
    }
}
#[cfg(test)]
#[test]
fn preedit_caret_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = PreeditCaretFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = PreeditCaretFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
impl<'a> From<PreeditCaretFr> for XimFrame<'a> {
    fn from(val: PreeditCaretFr) -> XimFrame<'a> {
        XimFrame::PreeditCaret(val)
    }
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,Copy,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct PreeditCaretReplyFr {
    pub input_method_id: u16,
    pub input_context_id: u16,
    pub position: u32,
}
impl Frame for PreeditCaretReplyFr {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (input_method_id, bytes) = u16::parse(bytes)?;
        let (input_context_id, bytes) = u16::parse(bytes)?;
        let (position, bytes) = u32::parse(bytes)?;
        Ok((Self {
            input_method_id,
            input_context_id,
            position,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size += 2;
        size += 4;
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.input_method_id.serialize(&mut target[posn..]);
        posn += self.input_context_id.serialize(&mut target[posn..]);
        posn += self.position.serialize(&mut target[posn..]);
        posn
    }
}
#[cfg(test)]
impl GenRandom for PreeditCaretReplyFr {
    fn generate() -> Self {
        Self {
            input_method_id: GenRandom::generate(),
            input_context_id: GenRandom::generate(),
            position: GenRandom::generate(),
        }
    }
}
#[cfg(test)]
#[test]
fn preedit_caret_reply_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = PreeditCaretReplyFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = PreeditCaretReplyFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
impl<'a> From<PreeditCaretReplyFr> for XimFrame<'a> {
    fn from(val: PreeditCaretReplyFr) -> XimFrame<'a> {
        XimFrame::PreeditCaretReply(val)
    }
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,Copy,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct PreeditDoneFr {
    pub input_method_id: u16,
    pub input_context_id: u16,
}
impl Frame for PreeditDoneFr {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (input_method_id, bytes) = u16::parse(bytes)?;
        let (input_context_id, bytes) = u16::parse(bytes)?;
        Ok((Self {
            input_method_id,
            input_context_id,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size += 2;
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.input_method_id.serialize(&mut target[posn..]);
        posn += self.input_context_id.serialize(&mut target[posn..]);
        posn
    }
}
#[cfg(test)]
impl GenRandom for PreeditDoneFr {
    fn generate() -> Self {
        Self {
            input_method_id: GenRandom::generate(),
            input_context_id: GenRandom::generate(),
        }
    }
}
#[cfg(test)]
#[test]
fn preedit_done_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = PreeditDoneFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = PreeditDoneFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
impl<'a> From<PreeditDoneFr> for XimFrame<'a> {
    fn from(val: PreeditDoneFr) -> XimFrame<'a> {
        XimFrame::PreeditDone(val)
    }
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,Copy,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct StatusStartFr {
    pub input_method_id: u16,
    pub input_context_id: u16,
}
impl Frame for StatusStartFr {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (input_method_id, bytes) = u16::parse(bytes)?;
        let (input_context_id, bytes) = u16::parse(bytes)?;
        Ok((Self {
            input_method_id,
            input_context_id,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size += 2;
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.input_method_id.serialize(&mut target[posn..]);
        posn += self.input_context_id.serialize(&mut target[posn..]);
        posn
    }
}
#[cfg(test)]
impl GenRandom for StatusStartFr {
    fn generate() -> Self {
        Self {
            input_method_id: GenRandom::generate(),
            input_context_id: GenRandom::generate(),
        }
    }
}
#[cfg(test)]
#[test]
fn status_start_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = StatusStartFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = StatusStartFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
impl<'a> From<StatusStartFr> for XimFrame<'a> {
    fn from(val: StatusStartFr) -> XimFrame<'a> {
        XimFrame::StatusStart(val)
    }
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct StatusDrawTextFr<'a> {
    pub input_method_id: u16,
    pub input_context_id: u16,
    pub ty: u32,
    pub status: u32,
    pub status_string: Cow<'a, [u8]>,
    pub feedback_array: Vec<u32>,
}
impl<'a> Frame for StatusDrawTextFr<'a> {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (input_method_id, bytes) = u16::parse(bytes)?;
        let (input_context_id, bytes) = u16::parse(bytes)?;
        let (ty, bytes) = u32::parse(bytes)?;
        let (status, bytes) = u32::parse(bytes)?;
        let (length_of_status_string, bytes) = u16::parse(bytes)?;
        
        if length_of_status_string as usize > bytes.len() {
            return Err(ParseError {
                expected: length_of_status_string as usize,
                got: bytes.len(),
            });
        }
        let (status_string, bytes) = bytes.split_at(length_of_status_string as usize);
        let status_string = Cow::Owned(status_string.to_vec());
                    
        
        let bytes_so_far = (bytes.as_ptr() as usize) - (_start.as_ptr() as usize);
        let padding_len = match bytes_so_far % 4 {
            0 => 0,
            rem => 4 - rem,
        };
        let bytes = bytes.get(padding_len..).ok_or(
            ParseError {
                expected: padding_len,
                got: bytes.len(),
            }
        )?;
                
        let (field7, bytes) = u16::parse(bytes)?;
        
        let bytes_so_far = (bytes.as_ptr() as usize) - (_start.as_ptr() as usize);
        let padding_len = match bytes_so_far % 4 {
            0 => 0,
            rem => 4 - rem,
        };
        let bytes = bytes.get(padding_len..).ok_or(
            ParseError {
                expected: padding_len,
                got: bytes.len(),
            }
        )?;
                
        
        let mut feedback_array = Vec::with_capacity(field7 as usize);
        let mut bytes = bytes;

        for _ in 0..field7 {
            let (val, rem) = u32::parse(bytes)?;
            feedback_array.push(val);
            bytes = rem;
        }
                
        Ok((Self {
            input_method_id,
            input_context_id,
            ty,
            status,
            status_string,
            feedback_array,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size += 2;
        size += 4;
        size += 4;
        size += 2;
        size += self.status_string.len();
        size = roundup(size, 4);
        size += 2;
        size = roundup(size, 4);
        size += self.feedback_array.iter().fold(0, |acc, t| acc + t.size());
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.input_method_id.serialize(&mut target[posn..]);
        posn += self.input_context_id.serialize(&mut target[posn..]);
        posn += self.ty.serialize(&mut target[posn..]);
        posn += self.status.serialize(&mut target[posn..]);
        posn += (self.status_string.len() as u16).serialize(&mut target[posn..]);
        
        let blen = self.status_string.len();
        target[posn..posn + blen].copy_from_slice(&self.status_string);
        posn += blen;
                
        posn = roundup(posn, 4);
        posn += (self.feedback_array.len() as u16).serialize(&mut target[posn..]);
        posn = roundup(posn, 4);
        
        for t in &self.feedback_array {
            posn += t.serialize(&mut target[posn..]);
        }
                
        posn
    }
}
#[cfg(test)]
impl<'a> GenRandom for StatusDrawTextFr<'a> {
    fn generate() -> Self {
        Self {
            input_method_id: GenRandom::generate(),
            input_context_id: GenRandom::generate(),
            ty: GenRandom::generate(),
            status: GenRandom::generate(),
            status_string: core::iter::repeat_with(|| fastrand::u8(..)).take(fastrand::usize(..255)).collect(),
            feedback_array: core::iter::repeat_with(GenRandom::generate).take(fastrand::usize(..255)).collect(),
        }
    }
}
#[cfg(test)]
#[test]
fn status_draw_text_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = StatusDrawTextFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = StatusDrawTextFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,Copy,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct StatusDrawBitmapFr {
    pub input_method_id: u16,
    pub input_context_id: u16,
    pub ty: u32,
    pub pixmap_data: u32,
}
impl Frame for StatusDrawBitmapFr {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (input_method_id, bytes) = u16::parse(bytes)?;
        let (input_context_id, bytes) = u16::parse(bytes)?;
        let (ty, bytes) = u32::parse(bytes)?;
        let (pixmap_data, bytes) = u32::parse(bytes)?;
        Ok((Self {
            input_method_id,
            input_context_id,
            ty,
            pixmap_data,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size += 2;
        size += 4;
        size += 4;
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.input_method_id.serialize(&mut target[posn..]);
        posn += self.input_context_id.serialize(&mut target[posn..]);
        posn += self.ty.serialize(&mut target[posn..]);
        posn += self.pixmap_data.serialize(&mut target[posn..]);
        posn
    }
}
#[cfg(test)]
impl GenRandom for StatusDrawBitmapFr {
    fn generate() -> Self {
        Self {
            input_method_id: GenRandom::generate(),
            input_context_id: GenRandom::generate(),
            ty: GenRandom::generate(),
            pixmap_data: GenRandom::generate(),
        }
    }
}
#[cfg(test)]
#[test]
fn status_draw_bitmap_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = StatusDrawBitmapFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = StatusDrawBitmapFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,Copy,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct StatusDoneFr {
    pub input_method_id: u16,
    pub input_context_id: u16,
}
impl Frame for StatusDoneFr {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (input_method_id, bytes) = u16::parse(bytes)?;
        let (input_context_id, bytes) = u16::parse(bytes)?;
        Ok((Self {
            input_method_id,
            input_context_id,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size += 2;
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.input_method_id.serialize(&mut target[posn..]);
        posn += self.input_context_id.serialize(&mut target[posn..]);
        posn
    }
}
#[cfg(test)]
impl GenRandom for StatusDoneFr {
    fn generate() -> Self {
        Self {
            input_method_id: GenRandom::generate(),
            input_context_id: GenRandom::generate(),
        }
    }
}
#[cfg(test)]
#[test]
fn status_done_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = StatusDoneFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = StatusDoneFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
impl<'a> From<StatusDoneFr> for XimFrame<'a> {
    fn from(val: StatusDoneFr) -> XimFrame<'a> {
        XimFrame::StatusDone(val)
    }
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,Copy,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct ExtSetEventMaskFr {
    pub input_method_id: u16,
    pub input_context_id: u16,
    pub filter_event_mask: u32,
    pub intercept_event_mask: u32,
    pub select_event_mask: u32,
    pub forward_event_mask: u32,
    pub synchronous_event_mask: u32,
}
impl Frame for ExtSetEventMaskFr {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (input_method_id, bytes) = u16::parse(bytes)?;
        let (input_context_id, bytes) = u16::parse(bytes)?;
        let (filter_event_mask, bytes) = u32::parse(bytes)?;
        let (intercept_event_mask, bytes) = u32::parse(bytes)?;
        let (select_event_mask, bytes) = u32::parse(bytes)?;
        let (forward_event_mask, bytes) = u32::parse(bytes)?;
        let (synchronous_event_mask, bytes) = u32::parse(bytes)?;
        Ok((Self {
            input_method_id,
            input_context_id,
            filter_event_mask,
            intercept_event_mask,
            select_event_mask,
            forward_event_mask,
            synchronous_event_mask,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size += 2;
        size += 4;
        size += 4;
        size += 4;
        size += 4;
        size += 4;
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.input_method_id.serialize(&mut target[posn..]);
        posn += self.input_context_id.serialize(&mut target[posn..]);
        posn += self.filter_event_mask.serialize(&mut target[posn..]);
        posn += self.intercept_event_mask.serialize(&mut target[posn..]);
        posn += self.select_event_mask.serialize(&mut target[posn..]);
        posn += self.forward_event_mask.serialize(&mut target[posn..]);
        posn += self.synchronous_event_mask.serialize(&mut target[posn..]);
        posn
    }
}
#[cfg(test)]
impl GenRandom for ExtSetEventMaskFr {
    fn generate() -> Self {
        Self {
            input_method_id: GenRandom::generate(),
            input_context_id: GenRandom::generate(),
            filter_event_mask: GenRandom::generate(),
            intercept_event_mask: GenRandom::generate(),
            select_event_mask: GenRandom::generate(),
            forward_event_mask: GenRandom::generate(),
            synchronous_event_mask: GenRandom::generate(),
        }
    }
}
#[cfg(test)]
#[test]
fn ext_set_event_mask_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = ExtSetEventMaskFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = ExtSetEventMaskFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,Copy,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct ExtForwardKeyeventFr {
    pub input_method_id: u16,
    pub input_context_id: u16,
    pub flag: u16,
    pub sequence_number: u16,
    pub x_event_u_u_type: u8,
    pub keycode: u8,
    pub state: u16,
    pub time: u32,
    pub window: u32,
}
impl Frame for ExtForwardKeyeventFr {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (input_method_id, bytes) = u16::parse(bytes)?;
        let (input_context_id, bytes) = u16::parse(bytes)?;
        let (flag, bytes) = u16::parse(bytes)?;
        let (sequence_number, bytes) = u16::parse(bytes)?;
        let (x_event_u_u_type, bytes) = u8::parse(bytes)?;
        let (keycode, bytes) = u8::parse(bytes)?;
        let (state, bytes) = u16::parse(bytes)?;
        let (time, bytes) = u32::parse(bytes)?;
        let (window, bytes) = u32::parse(bytes)?;
        Ok((Self {
            input_method_id,
            input_context_id,
            flag,
            sequence_number,
            x_event_u_u_type,
            keycode,
            state,
            time,
            window,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size += 2;
        size += 2;
        size += 2;
        size += 1;
        size += 1;
        size += 2;
        size += 4;
        size += 4;
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.input_method_id.serialize(&mut target[posn..]);
        posn += self.input_context_id.serialize(&mut target[posn..]);
        posn += self.flag.serialize(&mut target[posn..]);
        posn += self.sequence_number.serialize(&mut target[posn..]);
        posn += self.x_event_u_u_type.serialize(&mut target[posn..]);
        posn += self.keycode.serialize(&mut target[posn..]);
        posn += self.state.serialize(&mut target[posn..]);
        posn += self.time.serialize(&mut target[posn..]);
        posn += self.window.serialize(&mut target[posn..]);
        posn
    }
}
#[cfg(test)]
impl GenRandom for ExtForwardKeyeventFr {
    fn generate() -> Self {
        Self {
            input_method_id: GenRandom::generate(),
            input_context_id: GenRandom::generate(),
            flag: GenRandom::generate(),
            sequence_number: GenRandom::generate(),
            x_event_u_u_type: GenRandom::generate(),
            keycode: GenRandom::generate(),
            state: GenRandom::generate(),
            time: GenRandom::generate(),
            window: GenRandom::generate(),
        }
    }
}
#[cfg(test)]
#[test]
fn ext_forward_keyevent_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = ExtForwardKeyeventFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = ExtForwardKeyeventFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
#[derive(Debug,Clone,PartialEq,Eq,PartialOrd,Ord,Hash,Default,Copy,)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct ExtMoveFr {
    pub input_method_id: u16,
    pub input_context_id: u16,
    pub x: u16,
    pub y: u16,
}
impl Frame for ExtMoveFr {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let _start = bytes;
        let (input_method_id, bytes) = u16::parse(bytes)?;
        let (input_context_id, bytes) = u16::parse(bytes)?;
        let (x, bytes) = u16::parse(bytes)?;
        let (y, bytes) = u16::parse(bytes)?;
        Ok((Self {
            input_method_id,
            input_context_id,
            x,
            y,
        }, bytes))
    }
    fn size(&self) -> usize {
        let mut size = 0usize;
        size += 2;
        size += 2;
        size += 2;
        size += 2;
        size
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let mut posn = 0usize;
        posn += self.input_method_id.serialize(&mut target[posn..]);
        posn += self.input_context_id.serialize(&mut target[posn..]);
        posn += self.x.serialize(&mut target[posn..]);
        posn += self.y.serialize(&mut target[posn..]);
        posn
    }
}
#[cfg(test)]
impl GenRandom for ExtMoveFr {
    fn generate() -> Self {
        Self {
            input_method_id: GenRandom::generate(),
            input_context_id: GenRandom::generate(),
            x: GenRandom::generate(),
            y: GenRandom::generate(),
        }
    }
}
#[cfg(test)]
#[test]
fn ext_move_fr_sanity() {

    // serialize a randomly generated test case to a buffer
    let test_case = ExtMoveFr::generate();
    let mut target = alloc::vec![0u8; test_case.size()];
    assert_eq!(test_case.serialize(&mut target), test_case.size());

    // read the test case again from that buffer
    let (deser, rem) = ExtMoveFr::parse(&target).unwrap();
    assert_eq!(rem.len(), 0);

    // cases should be equal
    assert_eq!(test_case, deser);
            
}
#[repr(u8)]
enum Opcode {
    AuthNext = 12,
    AuthNg = 14,
    AuthReply = 11,
    AuthRequired = 10,
    AuthSetup = 13,
    Close = 32,
    CloseReply = 33,
    Commit = 63,
    Connect = 1,
    ConnectReply = 2,
    CreateIc = 50,
    CreateIcReply = 51,
    DestroyIc = 52,
    DestroyIcReply = 53,
    Disconnect = 3,
    DisconnectReply = 4,
    EncodingNegotiation = 38,
    EncodingNegotiationReply = 39,
    Error = 20,
    Extension = 128,
    ForwardEvent = 60,
    Geometry = 70,
    GetIcValues = 56,
    GetIcValuesReply = 57,
    GetImValues = 44,
    GetImValuesReply = 45,
    Open = 30,
    OpenReply = 31,
    PreeditCaret = 76,
    PreeditCaretReply = 77,
    PreeditDone = 78,
    PreeditDraw = 75,
    PreeditStart = 73,
    PreeditStartReply = 74,
    QueryExtension = 40,
    QueryExtensionReply = 41,
    RegisterTriggerkeys = 34,
    ResetIc = 64,
    ResetIcReply = 65,
    SetEventMask = 37,
    SetIcFocus = 58,
    SetIcValues = 54,
    SetIcValuesReply = 55,
    StatusDone = 81,
    StatusStart = 79,
    StrConversion = 71,
    StrConversionReply = 72,
    Sync = 61,
    SyncReply = 62,
    TriggerNotify = 35,
    TriggerNotifyReply = 36,
    UnsetIcFocus = 59,
}
impl TryFrom<u8> for Opcode {
    type Error = OutOfRange;
    fn try_from(val: u8) -> Result<Self, OutOfRange> {
        match val {
            12 => Ok(Opcode::AuthNext),
            14 => Ok(Opcode::AuthNg),
            11 => Ok(Opcode::AuthReply),
            10 => Ok(Opcode::AuthRequired),
            13 => Ok(Opcode::AuthSetup),
            32 => Ok(Opcode::Close),
            33 => Ok(Opcode::CloseReply),
            63 => Ok(Opcode::Commit),
            1 => Ok(Opcode::Connect),
            2 => Ok(Opcode::ConnectReply),
            50 => Ok(Opcode::CreateIc),
            51 => Ok(Opcode::CreateIcReply),
            52 => Ok(Opcode::DestroyIc),
            53 => Ok(Opcode::DestroyIcReply),
            3 => Ok(Opcode::Disconnect),
            4 => Ok(Opcode::DisconnectReply),
            38 => Ok(Opcode::EncodingNegotiation),
            39 => Ok(Opcode::EncodingNegotiationReply),
            20 => Ok(Opcode::Error),
            128 => Ok(Opcode::Extension),
            60 => Ok(Opcode::ForwardEvent),
            70 => Ok(Opcode::Geometry),
            56 => Ok(Opcode::GetIcValues),
            57 => Ok(Opcode::GetIcValuesReply),
            44 => Ok(Opcode::GetImValues),
            45 => Ok(Opcode::GetImValuesReply),
            30 => Ok(Opcode::Open),
            31 => Ok(Opcode::OpenReply),
            76 => Ok(Opcode::PreeditCaret),
            77 => Ok(Opcode::PreeditCaretReply),
            78 => Ok(Opcode::PreeditDone),
            75 => Ok(Opcode::PreeditDraw),
            73 => Ok(Opcode::PreeditStart),
            74 => Ok(Opcode::PreeditStartReply),
            40 => Ok(Opcode::QueryExtension),
            41 => Ok(Opcode::QueryExtensionReply),
            34 => Ok(Opcode::RegisterTriggerkeys),
            64 => Ok(Opcode::ResetIc),
            65 => Ok(Opcode::ResetIcReply),
            37 => Ok(Opcode::SetEventMask),
            58 => Ok(Opcode::SetIcFocus),
            54 => Ok(Opcode::SetIcValues),
            55 => Ok(Opcode::SetIcValuesReply),
            81 => Ok(Opcode::StatusDone),
            79 => Ok(Opcode::StatusStart),
            71 => Ok(Opcode::StrConversion),
            72 => Ok(Opcode::StrConversionReply),
            61 => Ok(Opcode::Sync),
            62 => Ok(Opcode::SyncReply),
            35 => Ok(Opcode::TriggerNotify),
            36 => Ok(Opcode::TriggerNotifyReply),
            59 => Ok(Opcode::UnsetIcFocus),
            _ => Err(OutOfRange),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Deserialize, serde::Serialize))]
pub enum XimFrame<'a> {
    AuthNext(AuthNextFr<'a>),
    AuthNg(AuthNgFr),
    AuthReply(AuthReplyFr<'a>),
    AuthRequired(AuthRequiredFr<'a>),
    AuthSetup(AuthSetupFr<'a>),
    Close(CloseFr),
    CloseReply(CloseReplyFr),
    Commit(CommitFr<'a>),
    Connect(ConnectFr<'a>),
    ConnectReply(ConnectReplyFr),
    CreateIc(CreateIcFr<'a>),
    CreateIcReply(CreateIcReplyFr),
    DestroyIc(DestroyIcFr),
    DestroyIcReply(DestroyIcReplyFr),
    Disconnect(DisconnectFr),
    DisconnectReply(DisconnectReplyFr),
    EncodingNegotiation(EncodingNegotiationFr<'a>),
    EncodingNegotiationReply(EncodingNegotiationReplyFr),
    Error(ErrorFr<'a>),
    ForwardEvent(ForwardEventFr),
    Geometry(GeometryFr),
    GetIcValues(GetIcValuesFr),
    GetIcValuesReply(GetIcValuesReplyFr<'a>),
    GetImValues(GetImValuesFr),
    GetImValuesReply(GetImValuesReplyFr<'a>),
    Open(OpenFr<'a>),
    OpenReply(OpenReplyFr<'a>),
    PreeditCaret(PreeditCaretFr),
    PreeditCaretReply(PreeditCaretReplyFr),
    PreeditDone(PreeditDoneFr),
    PreeditDraw(PreeditDrawFr<'a>),
    PreeditStart(PreeditStartFr),
    PreeditStartReply(PreeditStartReplyFr),
    QueryExtension(QueryExtensionFr<'a>),
    QueryExtensionReply(QueryExtensionReplyFr<'a>),
    RegisterTriggerkeys(RegisterTriggerkeysFr),
    ResetIc(ResetIcFr),
    ResetIcReply(ResetIcReplyFr<'a>),
    SetEventMask(SetEventMaskFr),
    SetIcFocus(SetIcFocusFr),
    SetIcValues(SetIcValuesFr<'a>),
    SetIcValuesReply(SetIcValuesReplyFr),
    StatusDone(StatusDoneFr),
    StatusStart(StatusStartFr),
    StrConversion(StrConversionFr<'a>),
    StrConversionReply(StrConversionReplyFr<'a>),
    Sync(SyncFr),
    SyncReply(SyncReplyFr),
    TriggerNotify(TriggerNotifyFr),
    TriggerNotifyReply(TriggerNotifyReplyFr),
    UnsetIcFocus(UnsetIcFocusFr),
    Extension {
        minor_opcode: u8,
        data: Vec<u8>,
    },
    Unknown {
        major_opcode: u8,
        minor_opcode: u8,
        data: Vec<u8>,
    },
}
impl<'a> Frame for XimFrame<'a> {
    fn parse(bytes: &[u8]) -> Result<WithRemainder<'_, Self>, ParseError> {
        let header = bytes.get(..4).ok_or(ParseError {
            expected: 4,
            got: bytes.len(),
        })?;
        match Opcode::try_from(header[0]) {
            Ok(Opcode::AuthNext) => {
                let (frame, rest) = AuthNextFr::parse(&bytes[4..])?;
                Ok((XimFrame::AuthNext(frame), rest))
            },
            Ok(Opcode::AuthNg) => {
                let (frame, rest) = AuthNgFr::parse(&bytes[4..])?;
                Ok((XimFrame::AuthNg(frame), rest))
            },
            Ok(Opcode::AuthReply) => {
                let (frame, rest) = AuthReplyFr::parse(&bytes[4..])?;
                Ok((XimFrame::AuthReply(frame), rest))
            },
            Ok(Opcode::AuthRequired) => {
                let (frame, rest) = AuthRequiredFr::parse(&bytes[4..])?;
                Ok((XimFrame::AuthRequired(frame), rest))
            },
            Ok(Opcode::AuthSetup) => {
                let (frame, rest) = AuthSetupFr::parse(&bytes[4..])?;
                Ok((XimFrame::AuthSetup(frame), rest))
            },
            Ok(Opcode::Close) => {
                let (frame, rest) = CloseFr::parse(&bytes[4..])?;
                Ok((XimFrame::Close(frame), rest))
            },
            Ok(Opcode::CloseReply) => {
                let (frame, rest) = CloseReplyFr::parse(&bytes[4..])?;
                Ok((XimFrame::CloseReply(frame), rest))
            },
            Ok(Opcode::Commit) => {
                let (frame, rest) = CommitFr::parse(&bytes[4..])?;
                Ok((XimFrame::Commit(frame), rest))
            },
            Ok(Opcode::Connect) => {
                let (frame, rest) = ConnectFr::parse(&bytes[4..])?;
                Ok((XimFrame::Connect(frame), rest))
            },
            Ok(Opcode::ConnectReply) => {
                let (frame, rest) = ConnectReplyFr::parse(&bytes[4..])?;
                Ok((XimFrame::ConnectReply(frame), rest))
            },
            Ok(Opcode::CreateIc) => {
                let (frame, rest) = CreateIcFr::parse(&bytes[4..])?;
                Ok((XimFrame::CreateIc(frame), rest))
            },
            Ok(Opcode::CreateIcReply) => {
                let (frame, rest) = CreateIcReplyFr::parse(&bytes[4..])?;
                Ok((XimFrame::CreateIcReply(frame), rest))
            },
            Ok(Opcode::DestroyIc) => {
                let (frame, rest) = DestroyIcFr::parse(&bytes[4..])?;
                Ok((XimFrame::DestroyIc(frame), rest))
            },
            Ok(Opcode::DestroyIcReply) => {
                let (frame, rest) = DestroyIcReplyFr::parse(&bytes[4..])?;
                Ok((XimFrame::DestroyIcReply(frame), rest))
            },
            Ok(Opcode::Disconnect) => {
                let (frame, rest) = DisconnectFr::parse(&bytes[4..])?;
                Ok((XimFrame::Disconnect(frame), rest))
            },
            Ok(Opcode::DisconnectReply) => {
                let (frame, rest) = DisconnectReplyFr::parse(&bytes[4..])?;
                Ok((XimFrame::DisconnectReply(frame), rest))
            },
            Ok(Opcode::EncodingNegotiation) => {
                let (frame, rest) = EncodingNegotiationFr::parse(&bytes[4..])?;
                Ok((XimFrame::EncodingNegotiation(frame), rest))
            },
            Ok(Opcode::EncodingNegotiationReply) => {
                let (frame, rest) = EncodingNegotiationReplyFr::parse(&bytes[4..])?;
                Ok((XimFrame::EncodingNegotiationReply(frame), rest))
            },
            Ok(Opcode::Error) => {
                let (frame, rest) = ErrorFr::parse(&bytes[4..])?;
                Ok((XimFrame::Error(frame), rest))
            },
            Ok(Opcode::ForwardEvent) => {
                let (frame, rest) = ForwardEventFr::parse(&bytes[4..])?;
                Ok((XimFrame::ForwardEvent(frame), rest))
            },
            Ok(Opcode::Geometry) => {
                let (frame, rest) = GeometryFr::parse(&bytes[4..])?;
                Ok((XimFrame::Geometry(frame), rest))
            },
            Ok(Opcode::GetIcValues) => {
                let (frame, rest) = GetIcValuesFr::parse(&bytes[4..])?;
                Ok((XimFrame::GetIcValues(frame), rest))
            },
            Ok(Opcode::GetIcValuesReply) => {
                let (frame, rest) = GetIcValuesReplyFr::parse(&bytes[4..])?;
                Ok((XimFrame::GetIcValuesReply(frame), rest))
            },
            Ok(Opcode::GetImValues) => {
                let (frame, rest) = GetImValuesFr::parse(&bytes[4..])?;
                Ok((XimFrame::GetImValues(frame), rest))
            },
            Ok(Opcode::GetImValuesReply) => {
                let (frame, rest) = GetImValuesReplyFr::parse(&bytes[4..])?;
                Ok((XimFrame::GetImValuesReply(frame), rest))
            },
            Ok(Opcode::Open) => {
                let (frame, rest) = OpenFr::parse(&bytes[4..])?;
                Ok((XimFrame::Open(frame), rest))
            },
            Ok(Opcode::OpenReply) => {
                let (frame, rest) = OpenReplyFr::parse(&bytes[4..])?;
                Ok((XimFrame::OpenReply(frame), rest))
            },
            Ok(Opcode::PreeditCaret) => {
                let (frame, rest) = PreeditCaretFr::parse(&bytes[4..])?;
                Ok((XimFrame::PreeditCaret(frame), rest))
            },
            Ok(Opcode::PreeditCaretReply) => {
                let (frame, rest) = PreeditCaretReplyFr::parse(&bytes[4..])?;
                Ok((XimFrame::PreeditCaretReply(frame), rest))
            },
            Ok(Opcode::PreeditDone) => {
                let (frame, rest) = PreeditDoneFr::parse(&bytes[4..])?;
                Ok((XimFrame::PreeditDone(frame), rest))
            },
            Ok(Opcode::PreeditDraw) => {
                let (frame, rest) = PreeditDrawFr::parse(&bytes[4..])?;
                Ok((XimFrame::PreeditDraw(frame), rest))
            },
            Ok(Opcode::PreeditStart) => {
                let (frame, rest) = PreeditStartFr::parse(&bytes[4..])?;
                Ok((XimFrame::PreeditStart(frame), rest))
            },
            Ok(Opcode::PreeditStartReply) => {
                let (frame, rest) = PreeditStartReplyFr::parse(&bytes[4..])?;
                Ok((XimFrame::PreeditStartReply(frame), rest))
            },
            Ok(Opcode::QueryExtension) => {
                let (frame, rest) = QueryExtensionFr::parse(&bytes[4..])?;
                Ok((XimFrame::QueryExtension(frame), rest))
            },
            Ok(Opcode::QueryExtensionReply) => {
                let (frame, rest) = QueryExtensionReplyFr::parse(&bytes[4..])?;
                Ok((XimFrame::QueryExtensionReply(frame), rest))
            },
            Ok(Opcode::RegisterTriggerkeys) => {
                let (frame, rest) = RegisterTriggerkeysFr::parse(&bytes[4..])?;
                Ok((XimFrame::RegisterTriggerkeys(frame), rest))
            },
            Ok(Opcode::ResetIc) => {
                let (frame, rest) = ResetIcFr::parse(&bytes[4..])?;
                Ok((XimFrame::ResetIc(frame), rest))
            },
            Ok(Opcode::ResetIcReply) => {
                let (frame, rest) = ResetIcReplyFr::parse(&bytes[4..])?;
                Ok((XimFrame::ResetIcReply(frame), rest))
            },
            Ok(Opcode::SetEventMask) => {
                let (frame, rest) = SetEventMaskFr::parse(&bytes[4..])?;
                Ok((XimFrame::SetEventMask(frame), rest))
            },
            Ok(Opcode::SetIcFocus) => {
                let (frame, rest) = SetIcFocusFr::parse(&bytes[4..])?;
                Ok((XimFrame::SetIcFocus(frame), rest))
            },
            Ok(Opcode::SetIcValues) => {
                let (frame, rest) = SetIcValuesFr::parse(&bytes[4..])?;
                Ok((XimFrame::SetIcValues(frame), rest))
            },
            Ok(Opcode::SetIcValuesReply) => {
                let (frame, rest) = SetIcValuesReplyFr::parse(&bytes[4..])?;
                Ok((XimFrame::SetIcValuesReply(frame), rest))
            },
            Ok(Opcode::StatusDone) => {
                let (frame, rest) = StatusDoneFr::parse(&bytes[4..])?;
                Ok((XimFrame::StatusDone(frame), rest))
            },
            Ok(Opcode::StatusStart) => {
                let (frame, rest) = StatusStartFr::parse(&bytes[4..])?;
                Ok((XimFrame::StatusStart(frame), rest))
            },
            Ok(Opcode::StrConversion) => {
                let (frame, rest) = StrConversionFr::parse(&bytes[4..])?;
                Ok((XimFrame::StrConversion(frame), rest))
            },
            Ok(Opcode::StrConversionReply) => {
                let (frame, rest) = StrConversionReplyFr::parse(&bytes[4..])?;
                Ok((XimFrame::StrConversionReply(frame), rest))
            },
            Ok(Opcode::Sync) => {
                let (frame, rest) = SyncFr::parse(&bytes[4..])?;
                Ok((XimFrame::Sync(frame), rest))
            },
            Ok(Opcode::SyncReply) => {
                let (frame, rest) = SyncReplyFr::parse(&bytes[4..])?;
                Ok((XimFrame::SyncReply(frame), rest))
            },
            Ok(Opcode::TriggerNotify) => {
                let (frame, rest) = TriggerNotifyFr::parse(&bytes[4..])?;
                Ok((XimFrame::TriggerNotify(frame), rest))
            },
            Ok(Opcode::TriggerNotifyReply) => {
                let (frame, rest) = TriggerNotifyReplyFr::parse(&bytes[4..])?;
                Ok((XimFrame::TriggerNotifyReply(frame), rest))
            },
            Ok(Opcode::UnsetIcFocus) => {
                let (frame, rest) = UnsetIcFocusFr::parse(&bytes[4..])?;
                Ok((XimFrame::UnsetIcFocus(frame), rest))
            },
            Ok(Opcode::Extension) => {
                let minor_opcode = bytes[1];
                let data = bytes[4..].to_vec();
                Ok((XimFrame::Extension { minor_opcode, data }, &[]))
            },
            Err(OutOfRange) => {
                let major_opcode = bytes[0];
                let minor_opcode = bytes[1];
                let data = bytes[4..].to_vec();
                Ok((XimFrame::Unknown { major_opcode, minor_opcode, data },
                   &[]))
            },
        }
    }
    fn size(&self) -> usize {
        let base_size = match self {
            XimFrame::AuthNext(frame) => frame.size(),
            XimFrame::AuthNg(frame) => frame.size(),
            XimFrame::AuthReply(frame) => frame.size(),
            XimFrame::AuthRequired(frame) => frame.size(),
            XimFrame::AuthSetup(frame) => frame.size(),
            XimFrame::Close(frame) => frame.size(),
            XimFrame::CloseReply(frame) => frame.size(),
            XimFrame::Commit(frame) => frame.size(),
            XimFrame::Connect(frame) => frame.size(),
            XimFrame::ConnectReply(frame) => frame.size(),
            XimFrame::CreateIc(frame) => frame.size(),
            XimFrame::CreateIcReply(frame) => frame.size(),
            XimFrame::DestroyIc(frame) => frame.size(),
            XimFrame::DestroyIcReply(frame) => frame.size(),
            XimFrame::Disconnect(frame) => frame.size(),
            XimFrame::DisconnectReply(frame) => frame.size(),
            XimFrame::EncodingNegotiation(frame) => frame.size(),
            XimFrame::EncodingNegotiationReply(frame) => frame.size(),
            XimFrame::Error(frame) => frame.size(),
            XimFrame::ForwardEvent(frame) => frame.size(),
            XimFrame::Geometry(frame) => frame.size(),
            XimFrame::GetIcValues(frame) => frame.size(),
            XimFrame::GetIcValuesReply(frame) => frame.size(),
            XimFrame::GetImValues(frame) => frame.size(),
            XimFrame::GetImValuesReply(frame) => frame.size(),
            XimFrame::Open(frame) => frame.size(),
            XimFrame::OpenReply(frame) => frame.size(),
            XimFrame::PreeditCaret(frame) => frame.size(),
            XimFrame::PreeditCaretReply(frame) => frame.size(),
            XimFrame::PreeditDone(frame) => frame.size(),
            XimFrame::PreeditDraw(frame) => frame.size(),
            XimFrame::PreeditStart(frame) => frame.size(),
            XimFrame::PreeditStartReply(frame) => frame.size(),
            XimFrame::QueryExtension(frame) => frame.size(),
            XimFrame::QueryExtensionReply(frame) => frame.size(),
            XimFrame::RegisterTriggerkeys(frame) => frame.size(),
            XimFrame::ResetIc(frame) => frame.size(),
            XimFrame::ResetIcReply(frame) => frame.size(),
            XimFrame::SetEventMask(frame) => frame.size(),
            XimFrame::SetIcFocus(frame) => frame.size(),
            XimFrame::SetIcValues(frame) => frame.size(),
            XimFrame::SetIcValuesReply(frame) => frame.size(),
            XimFrame::StatusDone(frame) => frame.size(),
            XimFrame::StatusStart(frame) => frame.size(),
            XimFrame::StrConversion(frame) => frame.size(),
            XimFrame::StrConversionReply(frame) => frame.size(),
            XimFrame::Sync(frame) => frame.size(),
            XimFrame::SyncReply(frame) => frame.size(),
            XimFrame::TriggerNotify(frame) => frame.size(),
            XimFrame::TriggerNotifyReply(frame) => frame.size(),
            XimFrame::UnsetIcFocus(frame) => frame.size(),
            XimFrame::Extension { data, .. } => data.len(),
            XimFrame::Unknown { data, .. } => data.len(),
        };
        base_size + HEADER_SIZE
    }
    fn serialize(&self, target: &mut [u8]) -> usize {
        let (major, minor, len) = match self {
            XimFrame::AuthNext(frame) => {
                let major = Opcode::AuthNext as u8;
                let len = frame.serialize(&mut target[HEADER_SIZE..]);
                (major, 0, len)
            },
            XimFrame::AuthNg(frame) => {
                let major = Opcode::AuthNg as u8;
                let len = frame.serialize(&mut target[HEADER_SIZE..]);
                (major, 0, len)
            },
            XimFrame::AuthReply(frame) => {
                let major = Opcode::AuthReply as u8;
                let len = frame.serialize(&mut target[HEADER_SIZE..]);
                (major, 0, len)
            },
            XimFrame::AuthRequired(frame) => {
                let major = Opcode::AuthRequired as u8;
                let len = frame.serialize(&mut target[HEADER_SIZE..]);
                (major, 0, len)
            },
            XimFrame::AuthSetup(frame) => {
                let major = Opcode::AuthSetup as u8;
                let len = frame.serialize(&mut target[HEADER_SIZE..]);
                (major, 0, len)
            },
            XimFrame::Close(frame) => {
                let major = Opcode::Close as u8;
                let len = frame.serialize(&mut target[HEADER_SIZE..]);
                (major, 0, len)
            },
            XimFrame::CloseReply(frame) => {
                let major = Opcode::CloseReply as u8;
                let len = frame.serialize(&mut target[HEADER_SIZE..]);
                (major, 0, len)
            },
            XimFrame::Commit(frame) => {
                let major = Opcode::Commit as u8;
                let len = frame.serialize(&mut target[HEADER_SIZE..]);
                (major, 0, len)
            },
            XimFrame::Connect(frame) => {
                let major = Opcode::Connect as u8;
                let len = frame.serialize(&mut target[HEADER_SIZE..]);
                (major, 0, len)
            },
            XimFrame::ConnectReply(frame) => {
                let major = Opcode::ConnectReply as u8;
                let len = frame.serialize(&mut target[HEADER_SIZE..]);
                (major, 0, len)
            },
            XimFrame::CreateIc(frame) => {
                let major = Opcode::CreateIc as u8;
                let len = frame.serialize(&mut target[HEADER_SIZE..]);
                (major, 0, len)
            },
            XimFrame::CreateIcReply(frame) => {
                let major = Opcode::CreateIcReply as u8;
                let len = frame.serialize(&mut target[HEADER_SIZE..]);
                (major, 0, len)
            },
            XimFrame::DestroyIc(frame) => {
                let major = Opcode::DestroyIc as u8;
                let len = frame.serialize(&mut target[HEADER_SIZE..]);
                (major, 0, len)
            },
            XimFrame::DestroyIcReply(frame) => {
                let major = Opcode::DestroyIcReply as u8;
                let len = frame.serialize(&mut target[HEADER_SIZE..]);
                (major, 0, len)
            },
            XimFrame::Disconnect(frame) => {
                let major = Opcode::Disconnect as u8;
                let len = frame.serialize(&mut target[HEADER_SIZE..]);
                (major, 0, len)
            },
            XimFrame::DisconnectReply(frame) => {
                let major = Opcode::DisconnectReply as u8;
                let len = frame.serialize(&mut target[HEADER_SIZE..]);
                (major, 0, len)
            },
            XimFrame::EncodingNegotiation(frame) => {
                let major = Opcode::EncodingNegotiation as u8;
                let len = frame.serialize(&mut target[HEADER_SIZE..]);
                (major, 0, len)
            },
            XimFrame::EncodingNegotiationReply(frame) => {
                let major = Opcode::EncodingNegotiationReply as u8;
                let len = frame.serialize(&mut target[HEADER_SIZE..]);
                (major, 0, len)
            },
            XimFrame::Error(frame) => {
                let major = Opcode::Error as u8;
                let len = frame.serialize(&mut target[HEADER_SIZE..]);
                (major, 0, len)
            },
            XimFrame::ForwardEvent(frame) => {
                let major = Opcode::ForwardEvent as u8;
                let len = frame.serialize(&mut target[HEADER_SIZE..]);
                (major, 0, len)
            },
            XimFrame::Geometry(frame) => {
                let major = Opcode::Geometry as u8;
                let len = frame.serialize(&mut target[HEADER_SIZE..]);
                (major, 0, len)
            },
            XimFrame::GetIcValues(frame) => {
                let major = Opcode::GetIcValues as u8;
                let len = frame.serialize(&mut target[HEADER_SIZE..]);
                (major, 0, len)
            },
            XimFrame::GetIcValuesReply(frame) => {
                let major = Opcode::GetIcValuesReply as u8;
                let len = frame.serialize(&mut target[HEADER_SIZE..]);
                (major, 0, len)
            },
            XimFrame::GetImValues(frame) => {
                let major = Opcode::GetImValues as u8;
                let len = frame.serialize(&mut target[HEADER_SIZE..]);
                (major, 0, len)
            },
            XimFrame::GetImValuesReply(frame) => {
                let major = Opcode::GetImValuesReply as u8;
                let len = frame.serialize(&mut target[HEADER_SIZE..]);
                (major, 0, len)
            },
            XimFrame::Open(frame) => {
                let major = Opcode::Open as u8;
                let len = frame.serialize(&mut target[HEADER_SIZE..]);
                (major, 0, len)
            },
            XimFrame::OpenReply(frame) => {
                let major = Opcode::OpenReply as u8;
                let len = frame.serialize(&mut target[HEADER_SIZE..]);
                (major, 0, len)
            },
            XimFrame::PreeditCaret(frame) => {
                let major = Opcode::PreeditCaret as u8;
                let len = frame.serialize(&mut target[HEADER_SIZE..]);
                (major, 0, len)
            },
            XimFrame::PreeditCaretReply(frame) => {
                let major = Opcode::PreeditCaretReply as u8;
                let len = frame.serialize(&mut target[HEADER_SIZE..]);
                (major, 0, len)
            },
            XimFrame::PreeditDone(frame) => {
                let major = Opcode::PreeditDone as u8;
                let len = frame.serialize(&mut target[HEADER_SIZE..]);
                (major, 0, len)
            },
            XimFrame::PreeditDraw(frame) => {
                let major = Opcode::PreeditDraw as u8;
                let len = frame.serialize(&mut target[HEADER_SIZE..]);
                (major, 0, len)
            },
            XimFrame::PreeditStart(frame) => {
                let major = Opcode::PreeditStart as u8;
                let len = frame.serialize(&mut target[HEADER_SIZE..]);
                (major, 0, len)
            },
            XimFrame::PreeditStartReply(frame) => {
                let major = Opcode::PreeditStartReply as u8;
                let len = frame.serialize(&mut target[HEADER_SIZE..]);
                (major, 0, len)
            },
            XimFrame::QueryExtension(frame) => {
                let major = Opcode::QueryExtension as u8;
                let len = frame.serialize(&mut target[HEADER_SIZE..]);
                (major, 0, len)
            },
            XimFrame::QueryExtensionReply(frame) => {
                let major = Opcode::QueryExtensionReply as u8;
                let len = frame.serialize(&mut target[HEADER_SIZE..]);
                (major, 0, len)
            },
            XimFrame::RegisterTriggerkeys(frame) => {
                let major = Opcode::RegisterTriggerkeys as u8;
                let len = frame.serialize(&mut target[HEADER_SIZE..]);
                (major, 0, len)
            },
            XimFrame::ResetIc(frame) => {
                let major = Opcode::ResetIc as u8;
                let len = frame.serialize(&mut target[HEADER_SIZE..]);
                (major, 0, len)
            },
            XimFrame::ResetIcReply(frame) => {
                let major = Opcode::ResetIcReply as u8;
                let len = frame.serialize(&mut target[HEADER_SIZE..]);
                (major, 0, len)
            },
            XimFrame::SetEventMask(frame) => {
                let major = Opcode::SetEventMask as u8;
                let len = frame.serialize(&mut target[HEADER_SIZE..]);
                (major, 0, len)
            },
            XimFrame::SetIcFocus(frame) => {
                let major = Opcode::SetIcFocus as u8;
                let len = frame.serialize(&mut target[HEADER_SIZE..]);
                (major, 0, len)
            },
            XimFrame::SetIcValues(frame) => {
                let major = Opcode::SetIcValues as u8;
                let len = frame.serialize(&mut target[HEADER_SIZE..]);
                (major, 0, len)
            },
            XimFrame::SetIcValuesReply(frame) => {
                let major = Opcode::SetIcValuesReply as u8;
                let len = frame.serialize(&mut target[HEADER_SIZE..]);
                (major, 0, len)
            },
            XimFrame::StatusDone(frame) => {
                let major = Opcode::StatusDone as u8;
                let len = frame.serialize(&mut target[HEADER_SIZE..]);
                (major, 0, len)
            },
            XimFrame::StatusStart(frame) => {
                let major = Opcode::StatusStart as u8;
                let len = frame.serialize(&mut target[HEADER_SIZE..]);
                (major, 0, len)
            },
            XimFrame::StrConversion(frame) => {
                let major = Opcode::StrConversion as u8;
                let len = frame.serialize(&mut target[HEADER_SIZE..]);
                (major, 0, len)
            },
            XimFrame::StrConversionReply(frame) => {
                let major = Opcode::StrConversionReply as u8;
                let len = frame.serialize(&mut target[HEADER_SIZE..]);
                (major, 0, len)
            },
            XimFrame::Sync(frame) => {
                let major = Opcode::Sync as u8;
                let len = frame.serialize(&mut target[HEADER_SIZE..]);
                (major, 0, len)
            },
            XimFrame::SyncReply(frame) => {
                let major = Opcode::SyncReply as u8;
                let len = frame.serialize(&mut target[HEADER_SIZE..]);
                (major, 0, len)
            },
            XimFrame::TriggerNotify(frame) => {
                let major = Opcode::TriggerNotify as u8;
                let len = frame.serialize(&mut target[HEADER_SIZE..]);
                (major, 0, len)
            },
            XimFrame::TriggerNotifyReply(frame) => {
                let major = Opcode::TriggerNotifyReply as u8;
                let len = frame.serialize(&mut target[HEADER_SIZE..]);
                (major, 0, len)
            },
            XimFrame::UnsetIcFocus(frame) => {
                let major = Opcode::UnsetIcFocus as u8;
                let len = frame.serialize(&mut target[HEADER_SIZE..]);
                (major, 0, len)
            },
            XimFrame::Extension { minor_opcode, data, .. } => {
                let major = Opcode::Extension as u8;
                let len = data.len();
                target[HEADER_SIZE..HEADER_SIZE + len].copy_from_slice(data);
                (major, *minor_opcode, len)
            },
            XimFrame::Unknown { major_opcode, minor_opcode, data, .. } => {
                let len = data.len();
                target[HEADER_SIZE..HEADER_SIZE + len].copy_from_slice(data);
                (*major_opcode, *minor_opcode, len)
            },
        };
        let xlen = (roundup(len, 4) / 4) as u16;
        target[0] = major;
        target[1] = minor;
        xlen.serialize(&mut target[2..]);
        len + HEADER_SIZE
    }
}
struct OutOfRange;
const HEADER_SIZE: usize = 4;
#[cfg(test)]
#[test]
fn ximframe_sanity() {
    fn test_frame(test_case: XimFrame) {

        let mut target = alloc::vec![0u8; test_case.size()];
        assert_eq!(test_case.serialize(&mut target), test_case.size());
        let (deser, rem) = XimFrame::parse(&target).unwrap();
        assert_eq!(rem.len(), 0);
        assert_eq!(test_case, deser);
        
    }
    test_frame(AuthNextFr::generate().into());
    test_frame(AuthNgFr::generate().into());
    test_frame(AuthReplyFr::generate().into());
    test_frame(AuthRequiredFr::generate().into());
    test_frame(AuthSetupFr::generate().into());
    test_frame(CloseFr::generate().into());
    test_frame(CloseReplyFr::generate().into());
    test_frame(CommitFr::generate().into());
    test_frame(ConnectFr::generate().into());
    test_frame(ConnectReplyFr::generate().into());
    test_frame(CreateIcFr::generate().into());
    test_frame(CreateIcReplyFr::generate().into());
    test_frame(DestroyIcFr::generate().into());
    test_frame(DestroyIcReplyFr::generate().into());
    test_frame(DisconnectFr::generate().into());
    test_frame(DisconnectReplyFr::generate().into());
    test_frame(EncodingNegotiationFr::generate().into());
    test_frame(EncodingNegotiationReplyFr::generate().into());
    test_frame(ErrorFr::generate().into());
    test_frame(ForwardEventFr::generate().into());
    test_frame(GeometryFr::generate().into());
    test_frame(GetIcValuesFr::generate().into());
    test_frame(GetIcValuesReplyFr::generate().into());
    test_frame(GetImValuesFr::generate().into());
    test_frame(GetImValuesReplyFr::generate().into());
    test_frame(OpenFr::generate().into());
    test_frame(OpenReplyFr::generate().into());
    test_frame(PreeditCaretFr::generate().into());
    test_frame(PreeditCaretReplyFr::generate().into());
    test_frame(PreeditDoneFr::generate().into());
    test_frame(PreeditDrawFr::generate().into());
    test_frame(PreeditStartFr::generate().into());
    test_frame(PreeditStartReplyFr::generate().into());
    test_frame(QueryExtensionFr::generate().into());
    test_frame(QueryExtensionReplyFr::generate().into());
    test_frame(RegisterTriggerkeysFr::generate().into());
    test_frame(ResetIcFr::generate().into());
    test_frame(ResetIcReplyFr::generate().into());
    test_frame(SetEventMaskFr::generate().into());
    test_frame(SetIcFocusFr::generate().into());
    test_frame(SetIcValuesFr::generate().into());
    test_frame(SetIcValuesReplyFr::generate().into());
    test_frame(StatusDoneFr::generate().into());
    test_frame(StatusStartFr::generate().into());
    test_frame(StrConversionFr::generate().into());
    test_frame(StrConversionReplyFr::generate().into());
    test_frame(SyncFr::generate().into());
    test_frame(SyncReplyFr::generate().into());
    test_frame(TriggerNotifyFr::generate().into());
    test_frame(TriggerNotifyReplyFr::generate().into());
    test_frame(UnsetIcFocusFr::generate().into());

    test_frame(XimFrame::Extension { 
        minor_opcode: fastrand::u8(..),
        data: core::iter::repeat_with(|| fastrand::u8(..))
            .take(fastrand::usize(..255))
            .collect() 
    });
        

    test_frame(XimFrame::Unknown { 
        major_opcode: fastrand::u8(129..),
        minor_opcode: fastrand::u8(..), 
        data: core::iter::repeat_with(|| fastrand::u8(..))
            .take(fastrand::usize(..255))
            .collect() 
    });
        
}
